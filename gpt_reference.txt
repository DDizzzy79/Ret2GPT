
This is example4/zic.c.
//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <errno.h>
#include <getopt.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_lldiv_t {
    int64_t e0;
    int64_t e1;
};

// ------------------- Function Prototypes --------------------

int32_t addtt(int64_t a1, int32_t a2, int32_t a3);
int32_t addtype(int32_t a1, int32_t str, uint32_t a3, uint32_t a4, uint32_t a5);
int32_t adjleap(void);
int32_t associate(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t byword(int32_t a1, char (**a2)[5]);
int32_t ciequal(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t convert(int32_t result, int32_t * a2);
int32_t convert64(int64_t a1, int32_t a2, int32_t * a3);
int32_t doabbr(int32_t str3, uint32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t dolink(int32_t a1, int32_t a2);
int32_t eat(int32_t a1, int32_t a2);
int32_t eats(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t eitol(int32_t result);
int32_t error(int32_t a1);
int32_t getfields(int32_t * str);
int32_t gethms(int32_t a1, char * a2, int32_t a3);
int32_t icatalloc(int32_t str2, int32_t str);
int32_t icpyalloc(char * a1);
int32_t ifree(int32_t a1);
int32_t imalloc(int32_t a1);
int32_t infile(int32_t a1);
int32_t inleap(int32_t a1, int32_t a2);
int32_t inlink(int32_t a1, int32_t a2);
int32_t inrule(int32_t a1, int32_t a2);
int32_t inzcont(int32_t a1, int32_t a2);
int32_t inzone(int32_t a1, int32_t a2);
int32_t inzsub(int32_t a1, int32_t a2, int32_t a3);
int32_t irealloc(int32_t a1, int32_t a2);
int32_t is32(int32_t a1, int32_t a2);
int32_t itsabbr(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t itsdir(int32_t a1);
int32_t leapadd(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t lowerit(uint32_t a1);
int32_t memcheck(int32_t result);
int32_t mkdirs(int32_t a1);
int32_t newabbr(int32_t a1);
int32_t oadd(int32_t a1, int32_t a2);
int32_t outzone(int32_t a1, uint32_t a2);
int32_t puttzcode(int32_t a1, int32_t stream);
int32_t puttzcode64(int32_t a1, int32_t a2, int32_t stream);
int32_t rpytime(int32_t * a1, int32_t a2);
int32_t rulesub(int32_t * a1, int32_t str2, int32_t str3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t scheck(int32_t str2, char * str);
int32_t setboundaries(void);
int32_t stringoffset(int32_t a1, int32_t a2);
int32_t stringrule(int32_t str, int32_t a2, int32_t a3, int32_t a4);
int32_t stringzone(int32_t result, int32_t a2, int32_t a3);
int32_t tadd(int64_t a1, int32_t a2, int32_t a3);
int32_t updateminmax(int32_t result);
int32_t usage(void);
int32_t warning(char * a1);
int32_t writezone(int32_t a1, int32_t a2);
int32_t yearistype(int32_t a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g1 = -0x1c5f7000; // 0x10000
char (*g2)[5] = "Rule"; // 0x152a4
char (*g3)[8] = "January"; // 0x15338
char (*g4)[7] = "Sunday"; // 0x153e4
char (*g5)[12] = "last-Sunday"; // 0x15488
char (*g6)[8] = "minimum"; // 0x154d8
char (*g7)[8] = "minimum"; // 0x154f8
char (*g8)[8] = "Rolling"; // 0x1552c
int32_t g9 = 31; // 0x15544
int32_t g10 = 365; // 0x155a4
int16_t g11 = 47; // 0x157ec
int32_t g12 = 48; // 0x15b90
int32_t g13 = 0; // 0x15b94
int32_t g14 = 32; // 0x15ea4
int32_t g15 = 41; // 0x161d8
int32_t g16 = 0; // 0x1641c
int32_t g17 = 0; // 0x1e700
int32_t g18 = 0; // 0x1e708
int32_t g19 = 0; // 0x1e70c
struct _IO_FILE * g20 = NULL; // 0x1e710
struct _IO_FILE * g21 = NULL; // 0x1e714
int32_t g22 = 0; // 0x1e720
int32_t g23 = 0; // 0x1e724
char * g24; // 0x1e728
int32_t g25 = 0; // 0x1e734
int32_t g26 = 0; // 0x1e738
int32_t g27 = 0; // 0x1e73c
int32_t g28 = 0; // 0x1e740
int32_t g29 = 0; // 0x1e744
int32_t g30 = 0; // 0x1e748
int32_t g31 = 0; // 0x1e74c
int32_t g32 = 0; // 0x1e750
int32_t g33 = 0; // 0x1e758
int32_t g34 = 0; // 0x1e75c
int32_t g35 = 0; // 0x1e760
int32_t g36 = 0; // 0x1e764
char * g37; // 0x1e768
int32_t g38 = 0; // 0x1e76c
char * g39; // 0x1e770
int32_t g40 = 0; // 0x1e774
int32_t g41 = 0; // 0x1e778
int32_t g42 = 0; // 0x1e77c
int32_t g43 = 0; // 0x1e780
int32_t g44 = 0; // 0x1e784
int32_t g45 = 0; // 0x1e788
int32_t g46 = 0; // 0x1e78c
int32_t g47 = 0; // 0x1e790
int32_t g48 = 0; // 0x1e798
int32_t g49 = 0; // 0x23298
char * g50; // 0x23698
char * g51; // 0x23798
char * g52; // 0x23898
char * g53; // 0x23998
char * g54; // 0x23a98
int64_t * g55 = NULL; // 0x23ad0
int32_t g56 = 0; // 0x23c60
char * g57; // 0x23d28
int32_t g58 = 0; // 0x23d5c
int32_t g59 = 0; // 0x23d60
char * g60; // 0x23d64
int32_t g61 = 0; // 0x23d68
char * g62; // 0x23d6c
int32_t g63 = 0; // 0x23d70
int32_t g64 = 0; // 0x23d78
int32_t g65 = 0; // 0x23d7c
int32_t g66 = 0; // 0x23d80
int32_t g67 = 0; // 0x23db4
char * g68; // 0x23db8
char * g69; // 0x23dc8
int32_t g70 = 0; // 0x23dd0
int32_t g71 = 0; // 0x23dd4
int32_t g72 = 0; // 0x23dd8
int32_t g73 = 0; // 0x23ddc
int32_t g74 = 0; // 0x23de0
char * g75; // 0x23de4
char * g76; // 0x23df8
int32_t g77 = 0; // 0x23dfc
int32_t g78 = 0; // 0x23e04
int64_t g79 = 0; // 0x23e48
int32_t g80 = 0; // 0x23e4c
char * g81; // 0x23e50
int32_t g82 = 0; // 0x23e54
int32_t g83 = 0; // 0x23e58
int32_t g84 = 0; // 0x23e59
int32_t g85 = 0; // 0x23e5c
int32_t g86 = 0; // 0x23e60
int32_t g87 = 0; // 0x23e64
int32_t g88 = 0; // 0x23e68
int32_t g89 = 0; // 0x23e6c
int32_t g90 = 0; // 0x23e70
int32_t g91 = 0; // 0x23e74
int32_t g92 = 0; // 0x23e78
int32_t g93 = 0; // 0x23e7c
int32_t g94 = 0; // 0x23e84
int32_t g95 = 0; // 0x23e88
int32_t g96 = 0; // 0x23e8c
int32_t g97 = 0; // 0x23e90
int32_t g98 = 0; // 0x23e94
int32_t g99 = 0; // 0x23e98
int32_t g100 = 0; // 0x23e9c
int32_t g101 = 0; // 0x23ea0
int32_t g102 = 0; // 0x23ea4
int32_t g103 = 0; // 0x23ea8
char * g104; // 0x23eac
int32_t g105 = 0x13c00; // 0x851f
int32_t g106 = -0x1af4ffd0; // 0xe72c
int32_t g107 = -0x15ffffd9; // 0xe730
int32_t g108 = -0x5f6fff1d; // 0xffff
int32_t g109;
int32_t g110;
int32_t g111;
int32_t g112;

// ------- Dynamically Linked Functions Without Header --------

struct _TYPEDEF_lldiv_t __aeabi_ldivmod(int64_t a1, int64_t a2);
int32_t __fputc_unlocked(int32_t a1, struct _IO_FILE * a2);

// ------------------------ Functions -------------------------

// Address range: 0x9030 - 0x90ac
int32_t memcheck(int32_t result) {
    if (result != 0) {
        // 0x909c
        return result;
    }
    // 0x904c
    fprintf(g21, "%s: Memory exhausted: %s\n", g39, strerror(*__errno_location()));
    exit(1);
    // UNREACHABLE
}

// Address range: 0x90ac - 0x9114
int32_t eats(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x90ac
    *(int32_t *)&g24 = result;
    g27 = a2;
    *(int32_t *)&g37 = a3;
    g38 = a4;
    return result;
}

// Address range: 0x9114 - 0x9144
int32_t eat(int32_t a1, int32_t a2) {
    // 0x9114
    return eats(a1, a2, 0, -1);
}

// Address range: 0x9144 - 0x9214
int32_t error(int32_t a1) {
    // 0x9144
    fprintf(g21, "\"%s\", line %d: %s", g24, g27, (char *)a1);
    if (g37 != NULL) {
        // 0x91a4
        fprintf(g21, " (rule from \"%s\", line %d)", g37, g38);
    }
    // 0x91d8
    g23++;
    return fputc(10, g21);
}

// Address range: 0x9214 - 0x9290
int32_t warning(char * a1) {
    int32_t v1 = memcheck(icpyalloc("warning: ")); // 0x9238
    int32_t v2 = memcheck(icatalloc(v1, (int32_t)a1)); // 0x9254
    error(v2);
    int32_t result = ifree(v2); // 0x9268
    g23--;
    return result;
}

// Address range: 0x9290 - 0x92d4
int32_t usage(void) {
    char * v1 = g39;
    fprintf(g21, "%s: usage is %s [ --version ] [ -v ] [ -l localtime ] [ -p posixrules ] \\\n\t[ -d directory ] [ -L leapseconds ] [ -y yearistype ] [ filename ... ]\n", v1, v1);
    exit(1);
    // UNREACHABLE
}

// Address range: 0x92d4 - 0x9a48
int main(int argc, char ** argv) {
    int32_t v1 = (int32_t)argv;
    umask(umask(18) | 18);
    *(int32_t *)&g39 = v1;
    int32_t v2 = 1; // 0x936c
    if (argc > 1) {
        while (strcmp((char *)*(int32_t *)(4 * v2 + v1), "--version") != 0) {
            // 0x9364
            v2++;
            if (v2 >= argc) {
                goto lab_0x9668;
            }
        }
        // 0x934c
        puts("@(#)zic.c\t8.17");
        exit(0);
        // UNREACHABLE
    }
  lab_0x9668:;
    int32_t v3 = getopt(argc, argv, "d:l:p:L:vsy:"); // 0x9678
    int32_t v4 = v3; // 0x9684
    if (v3 != -1) {
        while (true) {
            // 0x9374
            g109 = v4 - 76;
            switch (v4) {
                case 76: {
                    // 0x95d0
                    if (g61 != 0) {
                        // 0x9600
                        fprintf(g21, "%s: More than one -L option specified\n", g39);
                        exit(1);
                        // UNREACHABLE
                    }
                    // 0x95e4
                    g61 = g18;
                    // break -> 0x9668
                    break;
                }
                case 121: {
                    // 0x956c
                    if (g62 != NULL) {
                        // 0x959c
                        fprintf(g21, "%s: More than one -y option specified\n", g39);
                        exit(1);
                        // UNREACHABLE
                    }
                    // 0x9580
                    *(int32_t *)&g62 = g18;
                    // break -> 0x9668
                    break;
                }
                case 118: {
                    // 0x9634
                    g36 = 1;
                    // break -> 0x9668
                    break;
                }
                case 115: {
                    // 0x9648
                    printf("%s: -s ignored\n", g39);
                    // break -> 0x9668
                    break;
                }
                case 112: {
                    // 0x9508
                    if (g58 != 0) {
                        // 0x9538
                        fprintf(g21, "%s: More than one -p option specified\n", g39);
                        exit(1);
                        // UNREACHABLE
                    }
                    // 0x951c
                    g58 = g18;
                    // break -> 0x9668
                    break;
                }
                case 108: {
                    // 0x94a4
                    if (g59 != 0) {
                        // 0x94d4
                        fprintf(g21, "%s: More than one -l option specified\n", g39);
                        exit(1);
                        // UNREACHABLE
                    }
                    // 0x94b8
                    g59 = g18;
                    // break -> 0x9668
                    break;
                }
                case 100: {
                    // 0x9440
                    if (g60 != NULL) {
                        // 0x9470
                        fprintf(g21, "%s: More than one -d option specified\n", g39);
                        exit(1);
                        // UNREACHABLE
                    }
                    // 0x9454
                    *(int32_t *)&g60 = g18;
                    // break -> 0x9668
                    break;
                }
                default: {
                    // 0x943c
                    usage();
                    // UNREACHABLE
                }
            }
            int32_t v5 = getopt(argc, argv, "d:l:p:L:vsy:"); // 0x9678
            v4 = v5;
            if (v5 == -1) {
                goto lab_0x9690;
            }
        }
        // 0x943c
        usage();
        // UNREACHABLE
    }
  lab_0x9690:;
    int32_t v6 = argc - 1; // 0x9694
    int32_t v7 = v1; // 0x96a8
    if (v6 == g19) {
        // 0x96ac
        v7 = (int32_t)"=";
        if (strcmp((char *)*(int32_t *)(4 * v6 + v1), "=") == 0) {
            // 0x96e4
            usage();
            // UNREACHABLE
        }
    }
    // 0x96e8
    if (g60 == NULL) {
        // 0x96fc
        *(int32_t *)&g60 = (int32_t)"/usr/local/etc/zoneinfo";
    }
    // 0x9710
    if (g62 == NULL) {
        // 0x9724
        *(int32_t *)&g62 = (int32_t)"yearistype";
    }
    int32_t v8 = setboundaries(); // 0x9738
    int32_t v9 = g19; // 0x9750
    int32_t v10 = v8; // 0x9750
    if (g19 < argc && g61 != 0) {
        // 0x9768
        infile(g61);
        int32_t v11 = adjleap(); // 0x977c
        v9 = g19;
        v10 = v11;
    }
    int32_t v12 = v10; // 0x97b8
    int32_t v13 = g19; // 0x97b8
    if (v9 < argc) {
        int32_t v14 = v9 + 1; // 0x97ac
        int32_t v15 = v14; // 0x97b8
        v12 = infile(*(int32_t *)(4 * v9 + v1));
        v13 = v1;
        while (v14 < argc) {
            int32_t v16 = v15;
            v14 = v16 + 1;
            v15 = v14;
            v12 = infile(*(int32_t *)(4 * v16 + v1));
            v13 = v1;
        }
    }
    // 0x97bc
    if (g23 != 0) {
        // 0x97d0
        exit(1);
        // UNREACHABLE
    }
    // 0x97d8
    associate(v12, v7, v13, 0);
    if (g45 > 0) {
        int32_t v17 = 0;
        int32_t v18 = v17 + 1;
        int32_t v19; // 0x92d4
        while (v18 < g45) {
            // 0x9804
            v19 = v18;
            if (*(int32_t *)((128 * v18 || 8) + g44) != 0) {
                // break -> 0x9828
                break;
            }
            v18 = v19 + 1;
        }
        // 0x9828
        outzone(g44 + 128 * v17, v18 - v17);
        while (v18 < g45) {
            // 0x97f0
            v17 = v18;
            v18 = v17 + 1;
            while (v18 < g45) {
                // 0x9804
                v19 = v18;
                if (*(int32_t *)((128 * v18 || 8) + g44) != 0) {
                    // break -> 0x9828
                    break;
                }
                v18 = v19 + 1;
            }
            // 0x9828
            outzone(g44 + 128 * v17, v18 - v17);
        }
    }
    int32_t v20 = 0; // 0x999c
    if (g47 > 0) {
        int32_t v21 = 16 * v20; // 0x9880
        int32_t v22 = g46 + v21; // 0x9884
        eat(*(int32_t *)v22, *(int32_t *)(v22 + 4));
        int32_t v23 = g46 + v21; // 0x98c8
        dolink(*(int32_t *)(v23 + 8), *(int32_t *)(v23 + 12));
        int32_t str; // 0x9948
        if (g36 != 0 == g47 > 0) {
            for (int32_t i = 0; i < g47; i++) {
                // 0x9914
                str = *(int32_t *)((16 * i | 8) + g46);
                if (strcmp((char *)*(int32_t *)(g46 + (v21 || 12)), (char *)str) == 0) {
                    // 0x9964
                    warning("link to link");
                }
            }
        }
        int32_t v24 = v20 + 1; // 0x9988
        v20 = v24;
        while (v24 < g47) {
            // 0x9870
            v21 = 16 * v20;
            v22 = g46 + v21;
            eat(*(int32_t *)v22, *(int32_t *)(v22 + 4));
            v23 = g46 + v21;
            dolink(*(int32_t *)(v23 + 8), *(int32_t *)(v23 + 12));
            if (g36 != 0 == g47 > 0) {
                for (int32_t i = 0; i < g47; i++) {
                    // 0x9914
                    str = *(int32_t *)((16 * i | 8) + g46);
                    if (strcmp((char *)*(int32_t *)(g46 + (v21 || 12)), (char *)str) == 0) {
                        // 0x9964
                        warning("link to link");
                    }
                }
            }
            // 0x9988
            v24 = v20 + 1;
            v20 = v24;
        }
    }
    // 0x99a0
    if (g59 != 0) {
        // 0x99b4
        eat((int32_t)"command line", 1);
        dolink(g59, (int32_t)"localtime");
    }
    // 0x99e0
    if (g58 != 0) {
        // 0x99f4
        eat((int32_t)"command line", 1);
        dolink(g58, (int32_t)"posixrules");
    }
    // 0x9a20
    return g23 != 0;
}

// Address range: 0x9a48 - 0x9d2c
int32_t dolink(int32_t a1, int32_t a2) {
    // 0x9a48
    int32_t v1; // 0x9a48
    int32_t v2; // 0x9a48
    if ((char)v2 == 47) {
        // 0x9a6c
        v1 = memcheck(icpyalloc((char *)a1));
    } else {
        int32_t v3 = memcheck(icpyalloc(g60)); // 0x9aa4
        int32_t v4 = icatalloc(v3, (int32_t)&g11); // 0x9ab8
        v1 = memcheck(icatalloc(memcheck(v4), a1));
    }
    // 0x9ae8
    int32_t v5; // 0x9a48
    if ((char)v2 == 47) {
        // 0x9af8
        v5 = memcheck(icpyalloc((char *)a2));
    } else {
        int32_t v6 = memcheck(icpyalloc(g60)); // 0x9b30
        int32_t v7 = icatalloc(v6, (int32_t)&g11); // 0x9b44
        v5 = memcheck(icatalloc(memcheck(v7), a2));
    }
    int32_t v8 = itsdir(v5); // 0x9b78
    char * file_path = (char *)v5;
    if (v8 == 0) {
        // 0x9b88
        remove(file_path);
    }
    char * path1 = (char *)v1; // 0x9b98
    if (link(path1, file_path) == 0) {
        // 0x9d14
        ifree(v1);
        return ifree(v5);
    }
    // 0x9ba8
    if (mkdirs(v5) != 0) {
        // 0x9bbc
        exit(1);
        // UNREACHABLE
    }
    // 0x9bc4
    if (link(path1, file_path) == 0) {
        // 0x9d14
        ifree(v1);
        return ifree(v5);
    }
    // 0x9be0
    if (access(path1, F_OK) == 0) {
        // 0x9bf8
        if (itsdir(v1) == 0) {
            char * found_char_pos = strchr((char *)(a2 + 1), 47); // 0x9c4c
            int32_t v9 = 0; // 0x9c5c
            if (found_char_pos != NULL) {
                int32_t v10 = memcheck(icatalloc(0, (int32_t)"../")); // 0x9c34
                char * found_char_pos2 = strchr((char *)((int32_t)found_char_pos + 1), 47); // 0x9c4c
                char * v11 = found_char_pos2; // 0x9c5c
                int32_t v12 = v10; // 0x9c5c
                v9 = v10;
                while (found_char_pos2 != NULL) {
                    // 0x9c1c
                    v10 = memcheck(icatalloc(v12, (int32_t)"../"));
                    found_char_pos2 = strchr((char *)((int32_t)v11 + 1), 47);
                    v11 = found_char_pos2;
                    v12 = v10;
                    v9 = v10;
                }
            }
            int32_t path1_ = memcheck(icatalloc(v9, v1)); // 0x9c74
            if (symlink((char *)path1_, file_path) == 0) {
                // 0x9cac
                warning("hard link failed, symbolic link used");
                ifree(path1_);
                // 0x9d14
                ifree(v1);
                return ifree(v5);
            }
            // 0x9cac
            ifree(path1_);
        }
    }
    int32_t err_num = *__errno_location(); // 0x9cc0
    fprintf(g21, "%s: Can't link from %s to %s: %s\n", g39, path1, file_path, strerror(err_num));
    exit(1);
    // UNREACHABLE
}

// Address range: 0x9d2c - 0x9db0
int32_t setboundaries(void) {
    // 0x9d2c
    g33 = -1;
    g34 = -1;
    uint64_t v1 = *(int64_t *)&g33;
    int32_t v2 = 0; // 0x9d78
    int32_t v3 = v1;
    uint32_t v4 = (int32_t)(v1 / 0x100000000);
    int32_t v5 = 2 * v4; // 0x9d5c
    g33 = v5;
    v2++;
    uint64_t v6 = *(int64_t *)&g33;
    int32_t v7 = v6;
    int32_t v8 = v6 / 0x100000000;
    while (v2 < 63) {
        // 0x9d50
        v3 = v7;
        v4 = v8;
        v5 = 2 * v4;
        g33 = v5;
        v2++;
        v6 = *(int64_t *)&g33;
        v7 = v6;
        v8 = v6 / 0x100000000;
    }
    // 0x9d84
    g34 = 2 * v3 | (int32_t)(v5 < v4);
    int32_t result = -1 - v8;
    g30 = result;
    g31 = -1 - v7;
    return result;
}

// Address range: 0x9db0 - 0x9e2c
int32_t itsdir(int32_t a1) {
    int32_t v1 = memcheck(icpyalloc((char *)a1)); // 0x9dd0
    int32_t path = memcheck(icatalloc(v1, (int32_t)"/.")); // 0x9df0
    int32_t v2 = access((char *)path, F_OK); // 0x9e00
    ifree(path);
    return v2 == 0;
}

// Address range: 0x9e6c - 0xa420
int32_t associate(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 0; // 0x9e84
    int32_t v2 = a1; // 0x9e84
    if (g43 != 0) {
        // 0x9e88
        qsort((int32_t *)g42, g43, 80, (int32_t (*)(int32_t *, int32_t *))0x9e2c);
        v1 = g43;
        v2 = &g112;
        if (g43 > 1) {
            int32_t v3 = 0;
            int32_t v4 = 80 * v3; // 0x9edc
            int32_t v5 = v4 | 8;
            int32_t v6 = v4 + 80; // 0x9f08
            int32_t str = *(int32_t *)(g42 + 8 + v6); // 0x9f10
            int32_t strcmp_rc = strcmp((char *)*(int32_t *)(v5 + g42), (char *)str); // 0x9f1c
            int32_t v7 = strcmp_rc; // 0x9f28
            int32_t v8 = v3; // 0x9f28
            int32_t v9; // 0x9e6c
            int32_t v10; // 0x9e6c
            int32_t v11; // 0x9e6c
            int32_t v12; // 0x9e6c
            int32_t str2; // 0x9f80
            int32_t v13; // 0x9fc0
            int32_t v14; // 0xa02c
            int32_t v15; // 0xa074
            int32_t v16; // 0xa078
            int32_t v17; // 0xa0c4
            int32_t str3; // 0xa0cc
            int32_t strcmp_rc2; // 0xa0d8
            int32_t str4; // 0xa138
            int32_t v18; // 0xa1cc
            int32_t str5; // 0xa1a8
            int32_t strcmp_rc3; // 0xa1b4
            if (strcmp_rc == 0) {
                // 0x9f30
                str2 = *(int32_t *)(g42 + v6);
                v7 = 0;
                v8 = v3;
                if (strcmp((char *)*(int32_t *)(g42 + v4), (char *)str2) != 0) {
                    // 0x9fa0
                    v13 = g42 + v4;
                    eat(*(int32_t *)v13, *(int32_t *)(v13 + 4));
                    warning("same rule name in multiple files");
                    v14 = g42 + v6;
                    eat(*(int32_t *)v14, *(int32_t *)(v14 + 4));
                    v15 = warning("same rule name in multiple files");
                    v16 = v3 + 2;
                    v10 = v16;
                    v12 = v16;
                    v9 = v15;
                    if (v16 < g43) {
                        v11 = v10;
                        v17 = 80 * v11;
                        str3 = *(int32_t *)(g42 + 8 + v17);
                        strcmp_rc2 = strcmp((char *)*(int32_t *)(g42 + v5), (char *)str3);
                        v12 = v11;
                        v9 = strcmp_rc2;
                        while (strcmp_rc2 == 0) {
                            // 0xa0ec
                            str4 = *(int32_t *)(g42 + v17);
                            if (strcmp((char *)*(int32_t *)(g42 + v4), (char *)str4) != 0) {
                                // 0xa158
                                str5 = *(int32_t *)(g42 + v17);
                                strcmp_rc3 = strcmp((char *)*(int32_t *)(g42 + v6), (char *)str5);
                                v12 = v11;
                                v9 = strcmp_rc3;
                                if (strcmp_rc3 != 0) {
                                    // break -> 0xa1e4
                                    break;
                                }
                            }
                            // 0xa1cc
                            v18 = v11 + 1;
                            v10 = v18;
                            v12 = v18;
                            v9 = 0;
                            if (v18 >= g43) {
                                // break -> 0xa1e4
                                break;
                            }
                            v11 = v10;
                            v17 = 80 * v11;
                            str3 = *(int32_t *)(g42 + 8 + v17);
                            strcmp_rc2 = strcmp((char *)*(int32_t *)(g42 + v5), (char *)str3);
                            v12 = v11;
                            v9 = strcmp_rc2;
                        }
                    }
                    // 0xa1e4
                    v7 = v9;
                    v8 = v12 - 1;
                }
            }
            int32_t v19 = v8 + 1; // 0xa1e8
            v1 = g43;
            v2 = v7;
            while (g43 - 1 > v19) {
                // 0x9ec0
                v3 = v19;
                v4 = 80 * v3;
                v5 = v4 | 8;
                v6 = v4 + 80;
                str = *(int32_t *)(g42 + 8 + v6);
                strcmp_rc = strcmp((char *)*(int32_t *)(v5 + g42), (char *)str);
                v7 = strcmp_rc;
                v8 = v3;
                if (strcmp_rc == 0) {
                    // 0x9f30
                    str2 = *(int32_t *)(g42 + v6);
                    v7 = 0;
                    v8 = v3;
                    if (strcmp((char *)*(int32_t *)(g42 + v4), (char *)str2) != 0) {
                        // 0x9fa0
                        v13 = g42 + v4;
                        eat(*(int32_t *)v13, *(int32_t *)(v13 + 4));
                        warning("same rule name in multiple files");
                        v14 = g42 + v6;
                        eat(*(int32_t *)v14, *(int32_t *)(v14 + 4));
                        v15 = warning("same rule name in multiple files");
                        v16 = v3 + 2;
                        v10 = v16;
                        v12 = v16;
                        v9 = v15;
                        if (v16 < g43) {
                            v11 = v10;
                            v17 = 80 * v11;
                            str3 = *(int32_t *)(g42 + 8 + v17);
                            strcmp_rc2 = strcmp((char *)*(int32_t *)(g42 + v5), (char *)str3);
                            v12 = v11;
                            v9 = strcmp_rc2;
                            while (strcmp_rc2 == 0) {
                                // 0xa0ec
                                str4 = *(int32_t *)(g42 + v17);
                                if (strcmp((char *)*(int32_t *)(g42 + v4), (char *)str4) != 0) {
                                    // 0xa158
                                    str5 = *(int32_t *)(g42 + v17);
                                    strcmp_rc3 = strcmp((char *)*(int32_t *)(g42 + v6), (char *)str5);
                                    v12 = v11;
                                    v9 = strcmp_rc3;
                                    if (strcmp_rc3 != 0) {
                                        // break -> 0xa1e4
                                        break;
                                    }
                                }
                                // 0xa1cc
                                v18 = v11 + 1;
                                v10 = v18;
                                v12 = v18;
                                v9 = 0;
                                if (v18 >= g43) {
                                    // break -> 0xa1e4
                                    break;
                                }
                                v11 = v10;
                                v17 = 80 * v11;
                                str3 = *(int32_t *)(g42 + 8 + v17);
                                strcmp_rc2 = strcmp((char *)*(int32_t *)(g42 + v5), (char *)str3);
                                v12 = v11;
                                v9 = strcmp_rc2;
                            }
                        }
                        // 0xa1e4
                        v7 = v9;
                        v8 = v12 - 1;
                    }
                }
                // 0xa1e8
                v19 = v8 + 1;
                v1 = g43;
                v2 = v7;
            }
        }
    }
    int32_t v20 = 0; // 0xa248
    int32_t v21 = g45; // 0xa248
    int32_t v22 = v1; // 0xa248
    if (g45 > 0) {
        int32_t v23 = g44 + 128 * v20; // 0xa220
        *(int32_t *)(v23 + 28) = 0;
        *(int32_t *)(v23 + 32) = 0;
        v20++;
        v21 = g45;
        while (v20 < v21) {
            // 0xa20c
            v23 = g44 + 128 * v20;
            *(int32_t *)(v23 + 28) = 0;
            *(int32_t *)(v23 + 32) = 0;
            v20++;
            v21 = g45;
        }
        // 0xa238
        v22 = g43;
    }
    int32_t v24 = v21; // 0xa35c
    int32_t v25 = v2; // 0xa35c
    if (v22 > 0) {
        int32_t v26 = 0;
        int32_t v27 = g42 + 80 * v26; // 0xa274
        int32_t * str6 = (int32_t *)(v27 + 8);
        int32_t v28 = v26 + 1;
        int32_t v29 = v21; // 0xa2dc
        int32_t v30 = v28; // 0xa2dc
        int32_t v31 = v2; // 0xa2dc
        int32_t v32; // 0x9e6c
        int32_t v33; // 0x9e6c
        int32_t v34; // 0x9e6c
        int32_t v35; // 0x9e6c
        int32_t str7; // 0xa2a8
        int32_t strcmp_rc4; // 0xa2b4
        int32_t str8; // 0xa2a8
        int32_t strcmp_rc5; // 0xa2b4
        if (v28 < v22) {
            // 0xa280
            str7 = *(int32_t *)((80 * v28 | 8) + g42);
            strcmp_rc4 = strcmp((char *)*str6, (char *)str7);
            v34 = v28;
            v35 = v28;
            v32 = strcmp_rc4;
            if (strcmp_rc4 == 0) {
                v33 = v34 + 1;
                v35 = v33;
                v32 = 0;
                while (v33 < g43) {
                    // 0xa2cc
                    str8 = *(int32_t *)((80 * v33 | 8) + g42);
                    strcmp_rc5 = strcmp((char *)*str6, (char *)str8);
                    v34 = v33;
                    v35 = v33;
                    v32 = strcmp_rc5;
                    if (strcmp_rc5 != 0) {
                        // break -> 0xa2e0
                        break;
                    }
                    v33 = v34 + 1;
                    v35 = v33;
                    v32 = 0;
                }
            }
            // 0xa2e0
            v29 = g45;
            v30 = v35;
            v31 = v32;
        }
        int32_t v36 = v30;
        int32_t v37 = v29; // 0xa344
        int32_t v38 = v31; // 0xa344
        int32_t v39; // 0x9e6c
        int32_t v40; // 0xa2fc
        int32_t strcmp_rc6; // 0xa310
        int32_t v41; // 0xa330
        if (v29 > 0) {
            // 0xa2e8
            v39 = v36 - v26;
            v41 = 0;
            v40 = g44 + 128 * v41;
            strcmp_rc6 = strcmp((char *)*(int32_t *)(v40 + 16), (char *)*str6);
            if (strcmp_rc6 == 0) {
                // 0xa324
                *(int32_t *)(v40 + 28) = v27;
                *(int32_t *)(v40 + 32) = v39;
            }
            // 0xa330
            v41++;
            v37 = g45;
            v38 = strcmp_rc6;
            while (v41 < g45) {
                // 0xa2e8
                v40 = g44 + 128 * v41;
                strcmp_rc6 = strcmp((char *)*(int32_t *)(v40 + 16), (char *)*str6);
                if (strcmp_rc6 == 0) {
                    // 0xa324
                    *(int32_t *)(v40 + 28) = v27;
                    *(int32_t *)(v40 + 32) = v39;
                }
                // 0xa330
                v41++;
                v37 = g45;
                v38 = strcmp_rc6;
            }
        }
        int32_t v42 = v38;
        int32_t v43 = v37;
        int32_t v44 = g43; // 0xa354
        v24 = v43;
        v25 = v42;
        while (v36 < v44) {
            // 0xa254
            v26 = v36;
            v27 = g42 + 80 * v26;
            str6 = (int32_t *)(v27 + 8);
            v28 = v26 + 1;
            v29 = v43;
            v30 = v28;
            v31 = v42;
            if (v28 < v44) {
                // 0xa280
                str7 = *(int32_t *)((80 * v28 | 8) + g42);
                strcmp_rc4 = strcmp((char *)*str6, (char *)str7);
                v34 = v28;
                v35 = v28;
                v32 = strcmp_rc4;
                if (strcmp_rc4 == 0) {
                    v33 = v34 + 1;
                    v35 = v33;
                    v32 = 0;
                    while (v33 < g43) {
                        // 0xa2cc
                        str8 = *(int32_t *)((80 * v33 | 8) + g42);
                        strcmp_rc5 = strcmp((char *)*str6, (char *)str8);
                        v34 = v33;
                        v35 = v33;
                        v32 = strcmp_rc5;
                        if (strcmp_rc5 != 0) {
                            // break -> 0xa2e0
                            break;
                        }
                        v33 = v34 + 1;
                        v35 = v33;
                        v32 = 0;
                    }
                }
                // 0xa2e0
                v29 = g45;
                v30 = v35;
                v31 = v32;
            }
            // 0xa2e0
            v36 = v30;
            v37 = v29;
            v38 = v31;
            if (v29 > 0) {
                // 0xa2e8
                v39 = v36 - v26;
                v41 = 0;
                v40 = g44 + 128 * v41;
                strcmp_rc6 = strcmp((char *)*(int32_t *)(v40 + 16), (char *)*str6);
                if (strcmp_rc6 == 0) {
                    // 0xa324
                    *(int32_t *)(v40 + 28) = v27;
                    *(int32_t *)(v40 + 32) = v39;
                }
                // 0xa330
                v41++;
                v37 = g45;
                v38 = strcmp_rc6;
                while (v41 < g45) {
                    // 0xa2e8
                    v40 = g44 + 128 * v41;
                    strcmp_rc6 = strcmp((char *)*(int32_t *)(v40 + 16), (char *)*str6);
                    if (strcmp_rc6 == 0) {
                        // 0xa324
                        *(int32_t *)(v40 + 28) = v27;
                        *(int32_t *)(v40 + 32) = v39;
                    }
                    // 0xa330
                    v41++;
                    v37 = g45;
                    v38 = strcmp_rc6;
                }
            }
            // 0xa34c
            v42 = v38;
            v43 = v37;
            v44 = g43;
            v24 = v43;
            v25 = v42;
        }
    }
    int32_t v45 = 0; // 0xa3fc
    int32_t result = v25; // 0xa3fc
    if (v24 > 0) {
        int32_t v46 = g44 + 128 * v45; // 0xa37c
        int32_t v47 = v25; // 0xa388
        char * found_char_pos; // 0xa3cc
        if (*(int32_t *)(v46 + 32) == 0) {
            // 0xa38c
            eat(*(int32_t *)v46, *(int32_t *)(v46 + 4));
            *(int32_t *)(v46 + 24) = gethms(*(int32_t *)(v46 + 16), "unruly zone", 1);
            found_char_pos = strchr((char *)*(int32_t *)(v46 + 20), 37);
            v47 = (int32_t)found_char_pos;
            if (found_char_pos != NULL) {
                // 0xa3dc
                v47 = error((int32_t)"%s in ruleless zone");
            }
        }
        int32_t v48 = v47;
        v45++;
        result = v48;
        while (v45 < g45) {
            // 0xa368
            v46 = g44 + 128 * v45;
            v47 = v48;
            if (*(int32_t *)(v46 + 32) == 0) {
                // 0xa38c
                eat(*(int32_t *)v46, *(int32_t *)(v46 + 4));
                *(int32_t *)(v46 + 24) = gethms(*(int32_t *)(v46 + 16), "unruly zone", 1);
                found_char_pos = strchr((char *)*(int32_t *)(v46 + 20), 37);
                v47 = (int32_t)found_char_pos;
                if (found_char_pos != NULL) {
                    // 0xa3dc
                    v47 = error((int32_t)"%s in ruleless zone");
                }
            }
            // 0xa3e8
            v48 = v47;
            v45++;
            result = v48;
        }
    }
    // 0xa400
    if (g23 == 0) {
        // 0xa41c
        return result;
    }
    // 0xa414
    exit(1);
    // UNREACHABLE
}

// Address range: 0xa420 - 0xa88c
int32_t infile(int32_t a1) {
    // 0xa420
    int32_t v1; // bp-32, 0xa420
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 0x100c); // 0xa43c
    *v2 = a1;
    struct _IO_FILE * stream; // 0xa420
    char * str3; // 0xa420
    if (strcmp(str3, "-") == 0) {
        // 0xa468
        *v2 = (int32_t)"standard input";
        stream = g20;
    } else {
        struct _IO_FILE * file = fopen(str3, "r"); // 0xa4a8
        stream = file;
        if (file == NULL) {
            // 0xa4b8
            fprintf(g21, "%s: Can't open %s: %s\n", g39, str3, strerror(*__errno_location()));
            exit(1);
            // UNREACHABLE
        }
    }
    int32_t v3 = (int32_t)str3; // 0xa52c
    eat(v3, 1);
    int32_t str4; // bp-4136, 0xa420
    char * str = fgets((char *)&str4, 0x1000, stream); // 0xa550
    int32_t v4 = 0; // 0xa568
    int32_t v5 = 1; // 0xa568
    int32_t v6 = 0; // 0xa568
    if (str != (char *)&str4) {
      lab_0xa56c:
        // 0xa56c
        if (ferror(stream) != 0) {
            // 0xa7b0
            fprintf(g21, "%s: Error reading %s\n", g39, g24);
            exit(1);
            // UNREACHABLE
        }
        // 0xa7ec
        if (stream != g20) {
            // 0xa800
            if (fclose(stream) != 0) {
                int32_t err_num = *__errno_location(); // 0xa81c
                fprintf(g21, "%s: Error closing %s: %s\n", g39, g24, strerror(err_num));
                exit(1);
                // UNREACHABLE
            }
        }
        int32_t result = 0; // 0xa874
        if (v4 != 0) {
            // 0xa878
            result = error((int32_t)"expected continuation line not found");
        }
        // 0xa884
        return result;
    }
    char * found_char_pos = strchr((char *)&str4, 10); // 0xa59c
    while (found_char_pos != NULL) {
        int32_t v7 = v6;
        *found_char_pos = 0;
        int32_t v8 = getfields(&str4); // 0xa5d8
        int32_t * v9 = (int32_t *)v8;
        int32_t v10 = *v9; // 0xa63c
        int32_t str5 = v10; // 0xa644
        int32_t * v11 = v9; // 0xa644
        int32_t v12 = v7; // 0xa644
        if (v10 != 0) {
            if (strcmp((char *)str5, "-") == 0) {
                // 0xa614
                *v11 = (int32_t)&g63;
            }
            int32_t v13 = 1; // 0xa62c
            int32_t * v14 = (int32_t *)(4 * v13 + v8); // 0xa63c
            int32_t v15 = *v14; // 0xa63c
            str5 = v15;
            v11 = v14;
            int32_t v16 = v13; // 0xa644
            while (v15 != 0) {
                // 0xa5e8
                if (strcmp((char *)str5, "-") == 0) {
                    // 0xa614
                    *v11 = (int32_t)&g63;
                }
                // 0xa62c
                v13 = v16 + 1;
                v14 = (int32_t *)(4 * v13 + v8);
                v15 = *v14;
                str5 = v15;
                v11 = v14;
                v16 = v13;
            }
            // 0xa648
            v12 = v7;
            if (v13 != 0) {
                if (v7 == 0) {
                    int32_t v17 = byword(*v9, &g2); // 0xa67c
                    if (v17 == 0) {
                        // 0xa68c
                        error((int32_t)"input line of unknown type");
                        v12 = 0;
                    } else {
                        int32_t * v18 = (int32_t *)(v17 + 4); // 0xa69c
                        int32_t v19 = *v18; // 0xa69c
                        g110 = v19;
                        switch (v19) {
                            case 0: {
                                // 0xa6bc
                                inrule(v8, v13);
                                v12 = 0;
                                // break -> 0xa7a0
                                break;
                            }
                            case 1: {
                                // 0xa6d0
                                v12 = inzone(v8, v13);
                                // break -> 0xa7a0
                                break;
                            }
                            case 2: {
                                // 0xa6e4
                                inlink(v8, v13);
                                v12 = 0;
                                // break -> 0xa7a0
                                break;
                            }
                            case 3: {
                                // 0xa6f8
                                if (g61 == v3) {
                                    // 0xa758
                                    inleap(v8, v13);
                                    v12 = 0;
                                } else {
                                    // 0xa71c
                                    fprintf(g21, "%s: Leap line in non leap seconds file %s\n", g39, str3);
                                    v12 = 0;
                                }
                                // break -> 0xa7a0
                                break;
                            }
                            default: {
                                // 0xa76c
                                fprintf(g21, "%s: panic: Invalid l_value %d\n", g39, *v18);
                                exit(1);
                                // UNREACHABLE
                            }
                        }
                    }
                } else {
                    // 0xa658
                    v12 = inzcont(v8, v13);
                }
            }
        }
        // 0xa7a0
        v6 = v12;
        ifree(v8);
        v5++;
        eat(v3, v5);
        char * str2 = fgets((char *)&str4, 0x1000, stream); // 0xa550
        v4 = v6;
        if (str2 != (char *)&str4) {
            goto lab_0xa56c;
        }
        found_char_pos = strchr((char *)&str4, 10);
    }
    // 0xa5ac
    error((int32_t)"line too long");
    exit(1);
    // UNREACHABLE
}

// Address range: 0xa88c - 0xab68
int32_t gethms(int32_t a1, char * a2, int32_t a3) {
    // 0xa88c
    int32_t v1; // 0xa88c
    int32_t v2 = v1;
    char v3 = v1;
    if (a1 == 0 || v3 == 0) {
        // 0xab5c
        return 0;
    }
    int32_t v4 = (int32_t)(a3 != 0 == v3 == 45) + a1;
    int32_t format = scheck(v4, "%ld"); // 0xa91c
    char * str = (char *)v4; // 0xa934
    int32_t v5 = 0; // 0xa940
    if (sscanf(str, (char *)format) != 1) {
        int32_t format2 = scheck(v4, "%ld:%d"); // 0xa964
        v5 = 0;
        if (sscanf(str, (char *)format2) != 2) {
            // 0xa994
            if (sscanf(str, (char *)scheck(v4, "%ld:%d:%d")) != 3) {
                // 0xa9cc
                error((int32_t)a2);
                // 0xab5c
                return 0;
            }
        }
    }
    uint32_t v6 = 0;
    int32_t v7 = v5;
    if (v7 < 61 != (v7 >= 0 && v2 >= 0 && v6 <= 59)) {
        // 0xaa18
        error((int32_t)a2);
        // 0xab5c
        return 0;
    }
    if (v2 >= 0x91a2c) {
        // 0xaa3c
        error((int32_t)"time overflow");
        // 0xab5c
        return 0;
    }
    // 0xaa50
    if ((v6 || v7) == 0 == v2 == 24 == (g36 != 0)) {
        // 0xaa88
        warning("24:00 not handled by pre-1998 versions of zic");
    }
    // 0xaa94
    if (g36 != 0) {
        if (v2 < 25 != (v2 != 24 || (v6 || v7) == 0)) {
            // 0xaad8
            warning("values over 24 hours not handled by pre-2007 versions of zic");
        }
    }
    int32_t v8 = a3 != 0 == v3 == 45 ? -1 : 1;
    int32_t v9 = eitol(v8); // 0xaae8
    int32_t v10 = eitol(3600); // 0xaafc
    int32_t v11 = eitol(v8); // 0xab0c
    int32_t v12 = eitol(v6); // 0xab1c
    int32_t v13 = eitol(60); // 0xab28
    // 0xab5c
    return oadd(v9 * v2 * v10, (v13 * v12 + eitol(v7)) * v11);
}

// Address range: 0xab68 - 0xadd4
int32_t inrule(int32_t a1, int32_t a2) {
    if (a2 != 10) {
        // 0xadcc
        return error((int32_t)"wrong number of fields on Rule line");
    }
    int32_t * v1 = (int32_t *)(a1 + 4); // 0xab9c
    if (*(char *)*v1 == 0) {
        // 0xadcc
        return error((int32_t)"nameless rule");
    }
    // 0xabbc
    g64 = (int32_t)g24;
    g65 = g27;
    g67 = gethms(*(int32_t *)(a1 + 32), "invalid saved time", 1);
    int32_t v2 = *(int32_t *)(a1 + 12); // 0xac24
    int32_t v3 = *(int32_t *)(a1 + 16); // 0xac2c
    int32_t v4 = *(int32_t *)(a1 + 20); // 0xac34
    int32_t v5 = *(int32_t *)(a1 + 24); // 0xac3c
    int32_t v6 = *(int32_t *)(a1 + 28); // 0xac44
    rulesub(&g64, *(int32_t *)(a1 + 8), v2, v3, v4, v5, v6);
    int32_t v7 = icpyalloc((char *)*v1); // 0xac6c
    g66 = memcheck(v7);
    int32_t v8 = icpyalloc((char *)*(int32_t *)(a1 + 36)); // 0xac98
    char * str = (char *)memcheck(v8); // 0xacb4
    g68 = str;
    if (g28 < strlen(str)) {
        // 0xace8
        g28 = strlen(g68);
    }
    int32_t v9 = memcheck(irealloc(g42, 80 * g43 + 80)); // 0xad54
    g42 = v9;
    int32_t v10 = g43; // 0xad7c
    g43 = v10 + 1;
    // 0xadcc
    return (int32_t)memcpy((int32_t *)(80 * v10 + v9), &g64, 80);
}

// Address range: 0xadd4 - 0xb104
int32_t inzone(int32_t a1, int32_t a2) {
    if ((uint32_t)(a2 - 5) >= 5) {
        // 0xae00
        error((int32_t)"wrong number of fields on Zone line");
        // 0xb0f8
        return 0;
    }
    int32_t * str = (int32_t *)(a1 + 4); // 0xae18
    if (strcmp((char *)*str, "localtime") == 0 && g59 != 0) {
        int32_t str2 = memcheck(irealloc((int32_t)g69, 141)); // 0xae6c
        *(int32_t *)&g69 = str2;
        sprintf((char *)str2, "\"Zone %s\" line and -l option are mutually exclusive", "localtime");
        error((int32_t)g69);
        // 0xb0f8
        return 0;
    }
    // 0xaec0
    if (strcmp((char *)*str, "posixrules") == 0 && g58 != 0) {
        int32_t str3 = memcheck(irealloc((int32_t)g69, 142)); // 0xaf18
        *(int32_t *)&g69 = str3;
        sprintf((char *)str3, "\"Zone %s\" line and -p option are mutually exclusive", "posixrules");
        error((int32_t)g69);
        // 0xb0f8
        return 0;
    }
    int32_t v1 = 0; // 0xb0e0
    int32_t result; // 0xadd4
    if (g45 > 0) {
        int32_t v2 = 128 * v1; // 0xaf84
        int32_t str4 = *(int32_t *)((v2 | 8) + g44); // 0xaf8c
        int32_t len; // 0xafec
        int32_t len2; // 0xb014
        int32_t str5; // 0xb038
        int32_t v3; // 0xb05c
        int32_t v4; // 0xb074
        int32_t v5; // 0xb078
        int32_t v6; // 0xb094
        if (str4 != 0) {
            // 0xaf98
            if (strcmp((char *)str4, (char *)*str) == 0) {
                // 0xafd4
                len = strlen((char *)*str);
                len2 = strlen((char *)*(int32_t *)(g44 + v2));
                str5 = memcheck(irealloc((int32_t)g69, len + 132 + len2));
                *(int32_t *)&g69 = str5;
                v3 = *str;
                v4 = g44 + v2;
                v5 = *(int32_t *)v4;
                v6 = *(int32_t *)(v4 + 4);
                sprintf((char *)str5, "duplicate zone name %s (file \"%s\", line %d)", (char *)v3, (char *)v5, v6);
                error((int32_t)g69);
                result = 0;
                return result;
            }
        }
        int32_t v7 = g45; // 0xb0d8
        v1++;
        while (v1 < v7) {
            // 0xaf74
            v2 = 128 * v1;
            str4 = *(int32_t *)((v2 | 8) + g44);
            int32_t v8 = v7; // 0xaf94
            if (str4 != 0) {
                // 0xaf98
                if (strcmp((char *)str4, (char *)*str) == 0) {
                    // 0xafd4
                    len = strlen((char *)*str);
                    len2 = strlen((char *)*(int32_t *)(g44 + v2));
                    str5 = memcheck(irealloc((int32_t)g69, len + 132 + len2));
                    *(int32_t *)&g69 = str5;
                    v3 = *str;
                    v4 = g44 + v2;
                    v5 = *(int32_t *)v4;
                    v6 = *(int32_t *)(v4 + 4);
                    sprintf((char *)str5, "duplicate zone name %s (file \"%s\", line %d)", (char *)v3, (char *)v5, v6);
                    error((int32_t)g69);
                    result = 0;
                    return result;
                }
                // 0xaf98
                v8 = g45;
            }
            // 0xb0cc
            v7 = v8;
            v1++;
        }
    }
    // 0xb0e4
    result = inzsub(a1, a2, 0);
  lab_0xb0f8:
    // 0xb0f8
    return result;
}

// Address range: 0xb104 - 0xb164
int32_t inzcont(int32_t a1, int32_t a2) {
    int32_t result; // 0xb104
    if ((uint32_t)(a2 - 3) < 5) {
        // 0xb144
        result = inzsub(a1, a2, 1);
    } else {
        // 0xb130
        error((int32_t)"wrong number of fields on Zone continuation line");
        result = 0;
    }
    // 0xb158
    return result;
}

// Address range: 0xb164 - 0xb6b0
int32_t inzsub(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 4; // 0xb184
    int32_t v2 = 0; // 0xb184
    int32_t v3 = 6; // 0xb184
    int32_t v4 = 5; // 0xb184
    int32_t v5 = 4; // 0xb184
    int32_t v6 = 3; // 0xb184
    int32_t v7 = 8; // 0xb184
    int32_t v8 = 0; // 0xb184
    if (a3 == 0) {
        int32_t v9 = icpyalloc((char *)*(int32_t *)(a1 + 4)); // 0xb1e8
        v1 = 12;
        v2 = 8;
        v3 = 8;
        v4 = 7;
        v5 = 6;
        v6 = 5;
        v7 = 16;
        v8 = memcheck(v9);
    }
    // 0xb208
    g72 = v8;
    g70 = (int32_t)g24;
    g71 = g27;
    g73 = gethms(*(int32_t *)(v2 + a1), "invalid UTC offset", 1);
    int32_t * str = (int32_t *)(v7 + a1); // 0xb278
    char * found_char_pos = strchr((char *)*str, 37); // 0xb284
    if (found_char_pos != NULL) {
        char * str2 = (char *)((int32_t)found_char_pos + 1); // 0xb298
        if (*str2 != 115 || strchr(str2, 37) != NULL) {
            // 0xb2bc
            error((int32_t)"invalid abbreviation format");
            // 0xb6a4
            return 0;
        }
    }
    int32_t v10 = icpyalloc((char *)*(int32_t *)(v1 + a1)); // 0xb2e4
    g74 = memcheck(v10);
    int32_t v11 = icpyalloc((char *)*str); // 0xb318
    char * str3 = (char *)memcheck(v11); // 0xb334
    g75 = str3;
    if (g29 < strlen(str3)) {
        // 0xb368
        g29 = strlen(g75);
    }
    int32_t v12; // 0xb164
    if (v6 >= a2) {
        // 0xb390
        v12 = g45;
    } else {
        // 0xb3b0
        g76 = g24;
        g77 = g27;
        int32_t v13 = *(int32_t *)(4 * v6 + a1); // 0xb3ec
        int32_t v14 = (int32_t)"Jan"; // 0xb3f8
        if (v5 < a2) {
            // 0xb3fc
            v14 = *(int32_t *)(4 * v5 + a1);
        }
        int32_t v15 = (int32_t)L"10"; // 0xb420
        if (v4 < a2) {
            // 0xb424
            v15 = *(int32_t *)(4 * v4 + a1);
        }
        int32_t v16 = &g12; // 0xb448
        if (v3 < a2) {
            // 0xb44c
            v16 = *(int32_t *)(4 * v3 + a1);
        }
        // 0xb468
        rulesub((int32_t *)&g76, v13, (int32_t)"only", (int32_t)&g13, v14, v15, v16);
        int32_t v17 = rpytime((int32_t *)&g76, g78); // 0xb4a4
        int64_t v18 = v17; // 0xb4b0
        g79 = v18;
        g80 = g78;
        int32_t v19 = g45; // 0xb4c8
        v12 = v19;
        if (a3 != 0 && v19 >= 1) {
            uint32_t v20 = v17 >> 31; // 0xb4dc
            uint64_t v21 = *(int64_t *)&g33; // 0xb4e8
            uint32_t v22 = (int32_t)(v21 / 0x100000000); // 0xb4e8
            v12 = v19;
            if (((v21 ^ v18) % 2 != 0) < (v20 > v22)) {
                uint64_t v23 = *(int64_t *)&g30; // 0xb50c
                uint32_t v24 = (int32_t)(v23 / 0x100000000); // 0xb50c
                v12 = v19;
                if (((v23 ^ v18) % 2 != 0) < (v20 < v24)) {
                    uint64_t v25 = *(int64_t *)(128 * v19 - 8 + g44); // 0xb544
                    uint32_t v26 = (int32_t)(v25 / 0x100000000); // 0xb544
                    v12 = v19;
                    if (((v25 ^ v21) % 2 != 0) < (v22 < v26)) {
                        // 0xb560
                        v12 = v19;
                        if (((v25 ^ v23) % 2 != 0) < (v26 < v24)) {
                            // 0xb5a4
                            v12 = v19;
                            if (((v25 ^ v18) % 2 != 0) >= (v20 > v26)) {
                                // 0xb5e8
                                error((int32_t)"Zone continuation line end time is not after end time of previous line");
                                // 0xb6a4
                                return 0;
                            }
                        }
                    }
                }
            }
        }
    }
    int32_t v27 = memcheck(irealloc(g44, 128 * v12 + 128)); // 0xb630
    g44 = v27;
    int32_t v28 = g45; // 0xb658
    g45 = v28 + 1;
    memcpy((int32_t *)(128 * v28 + v27), &g70, 128);
    // 0xb6a4
    return v6 < a2;
}

// Address range: 0xb6b4 - 0xbd64
int32_t inleap(int32_t a1, int32_t a2) {
    struct _TYPEDEF_lldiv_t v1; // 0xbb64
    struct _TYPEDEF_lldiv_t v2; // 0xbbb8
    // 0xb6b4
    if (a2 != 7) {
        // 0xbd5c
        return error((int32_t)"wrong number of fields on Leap line");
    }
    int32_t str = *(int32_t *)(a1 + 4); // 0xb6ec
    if (sscanf((char *)str, (char *)scheck(str, "%d")) != 1) {
        // 0xbd5c
        return error((int32_t)"invalid leaping year");
    }
    int32_t v3 = *(int32_t *)((int32_t)&g107 & 0xffff | (int32_t)&g1); // 0xb73c
    int32_t v4; // 0xb6b4
    int32_t v5; // 0xb6b4
    int64_t v6; // 0xb6b4
    if (v3 == 0) {
        // 0xb734
        v4 = v6;
        goto lab_0xb770;
    } else {
        int32_t v7 = v6;
        v4 = v7;
        v5 = v7;
        if (g26 < v7) {
            goto lab_0xb770;
        } else {
            goto lab_0xb784;
        }
    }
  lab_0xb844:;
    // 0xb844
    int32_t v8; // 0xb6b4
    int32_t v9 = v8 + 1; // 0xb854
    int32_t v10; // 0xb6b4
    int32_t v11 = *(int32_t *)v10; // 0xb854
    goto lab_0xb8e0;
  lab_0xb8d0:;
    // 0xb8d0
    int32_t v19; // 0xb858
    v9 = v19;
    int32_t v22; // 0xb6b4
    v11 = -*(int32_t *)v22;
    goto lab_0xb8e0;
  lab_0xb8e0:;
    // 0xb8e0
    int32_t v12; // 0xb6b4
    int32_t v13 = oadd(v12, eitol(v11)); // 0xb8f4
    int32_t v14 = v9; // 0xb904
    v12 = v13;
    int32_t v15 = v13; // 0xb904
    int32_t v16; // 0xb6b4
    if (v9 == v16) {
        // break -> 0xb908
        goto lab_0xb908;
    }
    goto lab_0xb7c4;
  lab_0xb770:
    // 0xb770
    g26 = v4;
    int32_t v23 = *(int32_t *)((int32_t)&g107 & 0xffff | (int32_t)&g1);
    int32_t v24 = v6;
    v5 = v24;
    int32_t v25 = v24; // 0xb780
    if (v23 == 0) {
        goto lab_0xb79c;
    } else {
        goto lab_0xb784;
    }
  lab_0xb784:
    // 0xb784
    v25 = v5;
    v16 = v5;
    if (g25 > v5) {
        goto lab_0xb79c;
    } else {
        goto lab_0xb7ac;
    }
  lab_0xb79c:
    // 0xb79c
    g25 = v25;
    v16 = v25;
    goto lab_0xb7ac;
  lab_0xb7ac:
    // 0xb7ac
    *(int32_t *)((int32_t)&g107 & 0xffff | (int32_t)&g1) = 1;
    v14 = 1970;
    v12 = 0;
    v15 = 0;
    if (v16 != 1970) {
        while (true) {
          lab_0xb7c4:
            // 0xb7c4
            v8 = v14;
            if (v8 < v16) {
                if (v8 % 4 == 0) {
                    int32_t v17 = (int64_t)v8 * (int64_t)((int32_t)&g105 & 0xffff | 0x51eb0000) / 0x100000000; // 0xb7e8
                    int32_t v18 = v8 >> 31; // 0xb7f0
                    v10 = (int32_t)&g10 + 4;
                    if (v8 == 100 * ((v17 >> 5) - v18)) {
                        // 0xb80c
                        v10 = (int32_t)&g10 + 4;
                        if (v8 == 400 * ((v17 >> 7) - v18)) {
                            goto lab_0xb844;
                        } else {
                            // 0xb840
                            v10 = &g10;
                            goto lab_0xb844;
                        }
                    } else {
                        goto lab_0xb844;
                    }
                } else {
                    // 0xb840
                    v10 = &g10;
                    goto lab_0xb844;
                }
            } else {
                // 0xb858
                v19 = v8 - 1;
                if (v19 % 4 == 0) {
                    int32_t v20 = (int64_t)v19 * (int64_t)((int32_t)&g105 & 0xffff | 0x51eb0000) / 0x100000000; // 0xb874
                    int32_t v21 = v19 >> 31; // 0xb87c
                    v22 = (int32_t)&g10 + 4;
                    if (v19 == 100 * ((v20 >> 5) - v21)) {
                        // 0xb898
                        v22 = (int32_t)&g10 + 4;
                        if (v19 == 400 * ((v20 >> 7) - v21)) {
                            goto lab_0xb8d0;
                        } else {
                            // 0xb8cc
                            v22 = &g10;
                            goto lab_0xb8d0;
                        }
                    } else {
                        goto lab_0xb8d0;
                    }
                } else {
                    // 0xb8cc
                    v22 = &g10;
                    goto lab_0xb8d0;
                }
            }
        }
    }
  lab_0xb908:;
    int32_t v26 = byword(*(int32_t *)(a1 + 8), (char (**)[5])&g3); // 0xb91c
    if (v26 == 0) {
        // 0xbd5c
        return error((int32_t)"invalid month name");
    }
    int32_t v27 = *(int32_t *)(v26 + 4); // 0xb93c
    int32_t v28 = v15; // 0xba10
    if (v27 != 0) {
        int32_t v29 = (int64_t)v16 * (int64_t)((int32_t)&g105 & 0xffff | 0x51eb0000) / 0x100000000;
        int32_t v30 = v16 >> 31;
        int32_t v31 = -v16;
        int32_t v32 = v6 % 4 == 0 == (-100 * ((v29 >> 5) - v30) != v31 | -400 * ((v29 >> 7) - v30) == v31) ? 12 : 0;
        int32_t v33 = 0; // 0xba04
        int32_t v34 = v15; // 0xb9fc
        int32_t v35 = *(int32_t *)(4 * (v33 + v32) + (int32_t)&g9); // 0xb9e4
        v34 = oadd(v34, eitol(v35));
        v33++;
        v28 = v34;
        while (v33 != v27) {
            // 0xb94c
            v35 = *(int32_t *)(4 * (v33 + v32) + (int32_t)&g9);
            v34 = oadd(v34, eitol(v35));
            v33++;
            v28 = v34;
        }
    }
    int32_t str2 = *(int32_t *)(a1 + 12); // 0xba14
    int32_t v36; // 0xb6b4
    if (v36 < 1 | sscanf((char *)str2, (char *)scheck(str2, "%d")) != 1) {
        // 0xbd5c
        return error((int32_t)"invalid day of month");
    }
    // 0xba58
    int32_t v37; // 0xb6b4
    if (v6 % 4 == 0) {
        int32_t v38 = (int64_t)v16 * (int64_t)((int32_t)&g105 & 0xffff | 0x51eb0000) / 0x100000000; // 0xba74
        int32_t v39 = v16 >> 31; // 0xba7c
        int32_t v40 = -100 * ((v38 >> 5) - v39);
        v37 = 12;
        if (v40 == -v16) {
            // 0xba98
            v37 = 12;
            if (-400 * ((v38 >> 7) - v39) == v40) {
                goto lab_0xbad4;
            } else {
                // 0xbad0
                v37 = 0;
                goto lab_0xbad4;
            }
        } else {
            goto lab_0xbad4;
        }
    } else {
        // 0xbad0
        v37 = 0;
        goto lab_0xbad4;
    }
  lab_0xbad4:;
    int32_t v41 = *(int32_t *)(4 * (v37 + v27) + (int32_t)&g9); // 0xbaf4
    if (v41 < v36) {
        // 0xbd5c
        return error((int32_t)"invalid day of month");
    }
    uint32_t v42 = oadd(v28, eitol(v36 - 1)); // 0xbb30
    int32_t v43 = v42 < 0;
    int64_t v44 = *(int64_t *)&g33; // 0xbb4c
    v1 = __aeabi_ldivmod(v44 >> 32, 0x15180);
    if (((v43 - (int32_t)v44) % 2 != 0) < (v42 < (int32_t)v1.e0)) {
        // 0xbd5c
        return error((int32_t)"time too small");
    }
    int64_t v45 = *(int64_t *)&g30; // 0xbba0
    v2 = __aeabi_ldivmod(v45 >> 32, 0x15180);
    if ((((int32_t)v45 - v43) % 2 != 0) < (v42 > (int32_t)v2.e0)) {
        // 0xbd5c
        return error((int32_t)"time too large");
    }
    int32_t v46 = gethms(*(int32_t *)(a1 + 16), "invalid time of day", 0); // 0xbc38
    char * str3 = (char *)*(int32_t *)(a1 + 20); // 0xbc44
    int32_t v47 = 1; // 0xbc4c
    int32_t v48 = 0; // 0xbc4c
    int32_t result2; // 0xb6b4
    if (*str3 != 0) {
        // 0xbc60
        v47 = 2;
        v48 = 0;
        if (strcmp(str3, "--") != 0) {
            // 0xbc8c
            v47 = 1;
            v48 = 1;
            if (strcmp(str3, "+") != 0) {
                // 0xbcb8
                v47 = 2;
                v48 = 1;
                if (strcmp(str3, "++") != 0) {
                    // 0xbce4
                    result2 = error((int32_t)"illegal CORRECTION field on Leap line");
                    int32_t result = result2;
                    return result;
                }
            }
        }
    }
    int32_t v49 = byword(*(int32_t *)(a1 + 24), (char (**)[5])&g8); // 0xbd08
    if (v49 == 0) {
        // 0xbd18
        result2 = error((int32_t)"illegal Rolling/Stationary field on Leap line");
    } else {
        int32_t v50 = 0x15180 * v42; // 0xbc0c
        int32_t v51 = tadd((int64_t)(v50 >> 31), v50, v46); // 0xbd30
        result2 = leapadd(v51, v50, v48, *(int32_t *)(v49 + 4), v47);
    }
    // 0xbd5c
    return result2;
}

// Address range: 0xbd64 - 0xbedc
int32_t inlink(int32_t a1, int32_t a2) {
    if (a2 != 3) {
        // 0xbed4
        return error((int32_t)"wrong number of fields on Link line");
    }
    char * v1 = (char *)*(int32_t *)(a1 + 4); // 0xbd9c
    if (*v1 == 0) {
        // 0xbed4
        return error((int32_t)"blank FROM field on Link line");
    }
    int32_t * v2 = (int32_t *)(a1 + 8); // 0xbdbc
    int32_t result; // 0xbd64
    if (*(char *)*v2 == 0) {
        // 0xbdcc
        result = error((int32_t)"blank TO field on Link line");
    } else {
        int32_t v3 = memcheck(icpyalloc(v1)); // 0xbe14
        int32_t v4 = memcheck(icpyalloc((char *)*v2)); // 0xbe38
        int32_t v5 = memcheck(irealloc(g46, 16 * g47 + 16)); // 0xbe78
        g46 = v5;
        int32_t v6 = g47; // 0xbea0
        g47 = v6 + 1;
        int32_t v7 = 16 * v6 + v5; // 0xbec0
        int32_t v8 = (int32_t)g24; // 0xbecc
        *(int32_t *)v7 = v8;
        *(int32_t *)(v7 + 4) = g27;
        *(int32_t *)(v7 + 8) = v3;
        *(int32_t *)(v7 + 12) = v4;
        result = v8;
    }
    // 0xbed4
    return result;
}

// Address range: 0xbedc - 0xc46c
int32_t rulesub(int32_t * a1, int32_t str2, int32_t str3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = byword(a5, (char (**)[5])&g3); // 0xbf04
    if (v1 == 0) {
        // 0xc464
        return error((int32_t)"invalid month name");
    }
    int32_t v2 = (int32_t)a1;
    int32_t * v3 = (int32_t *)(v2 + 32); // 0xbf28
    *v3 = *(int32_t *)(v1 + 4);
    int32_t * v4 = (int32_t *)(v2 + 52); // 0xbf30
    *v4 = 0;
    int32_t * v5 = (int32_t *)(v2 + 56); // 0xbf38
    *v5 = 0;
    int32_t v6 = memcheck(icpyalloc((char *)a7)); // 0xbf4c
    char * str = (char *)v6; // 0xbf54
    int32_t v7; // 0xbedc
    if (*str != 0) {
        char * v8 = (char *)(v6 - 1 + strlen(str)); // 0xbf74
        int32_t v9 = lowerit((int32_t)*v8); // 0xbf7c
        int32_t v10 = v9 - 103; // 0xbf84
        v7 = v10;
        g111 = v10;
        switch (v9) {
            case 103: {
            }
            case 122: {
            }
            case 117: {
                // 0xc01c
                *v4 = 1;
                *v5 = 1;
                *v8 = 0;
                // break -> 0xc038
                break;
            }
            case 119: {
                // 0xc000
                *v4 = 0;
                *v5 = 0;
                *v8 = 0;
                // break -> 0xc038
                break;
            }
            case 115: {
                // 0xbfe4
                *v4 = 1;
                *v5 = 0;
                *v8 = 0;
                // break -> 0xc038
                break;
            }
        }
    }
    int32_t v11 = gethms(v6, "invalid time of day", 0); // 0xc048
    v7 = v11;
    *(int32_t *)(v2 + 48) = v11;
    ifree(v6);
    int32_t v12 = byword(str2, (char (**)[5])&g6); // 0xc06c
    int32_t v13 = v12 == 0;
    v7 = v13;
    *(int32_t *)(v2 + 24) = v13;
    if (v12 != 0) {
        int32_t * v14 = (int32_t *)(v12 + 4); // 0xc094
        int32_t v15 = *v14; // 0xc094
        v7 = v15;
        switch (v15) {
            case 0: {
                // 0xc0ac
                v7 = -0x80000000;
                *(int32_t *)(v2 + 12) = -0x80000000;
                // break -> 0xc140
                break;
            }
            case 1: {
                // 0xc0b8
                v7 = 0x7fffffff;
                *(int32_t *)(v2 + 12) = 0x7fffffff;
                // break -> 0xc140
                break;
            }
            default: {
                // 0xc0c4
                fprintf(g21, "%s: panic: Invalid l_value %d\n", g39, *v14);
                exit(1);
                // UNREACHABLE
            }
        }
    } else {
        int32_t items_assigned = sscanf((char *)str2, (char *)scheck(str2, "%d")); // 0xc120
        v7 = items_assigned;
        if (items_assigned != 1) {
            // 0xc464
            return error((int32_t)"invalid starting year");
        }
    }
    int32_t v16 = byword(str3, (char (**)[5])&g7); // 0xc150
    int32_t v17 = v16 == 0;
    v7 = v17;
    *(int32_t *)(v2 + 28) = v17;
    int32_t v18; // 0xbedc
    int32_t v19; // 0xbedc
    int32_t v20; // 0xbedc
    if (v16 != 0) {
        int32_t * v21 = (int32_t *)(v16 + 4); // 0xc178
        int32_t v22 = *v21; // 0xc178
        v7 = v22;
        switch (v22) {
            case 1: {
                // 0xc234
                *(int32_t *)(v2 + 16) = 0x7fffffff;
                v19 = *(int32_t *)(v2 + 12);
                v20 = 0x7fffffff;
                goto lab_0xc254;
            }
            case 2: {
                int32_t v23 = *(int32_t *)(v2 + 12); // 0xc1ac
                *(int32_t *)(v2 + 16) = v23;
                v18 = v23;
                goto lab_0xc234_2;
            }
            case 0: {
                // 0xc194
                *(int32_t *)(v2 + 16) = -0x80000000;
                v18 = -0x80000000;
                goto lab_0xc234_2;
            }
            default: {
                // 0xc1b8
                fprintf(g21, "%s: panic: Invalid l_value %d\n", g39, *v21);
                exit(1);
                // UNREACHABLE
            }
        }
    } else {
        // 0xc1f0
        if (sscanf((char *)str3, (char *)scheck(str3, "%d")) != 1) {
            // 0xc464
            return error((int32_t)"invalid ending year");
        }
        // 0xc1f0
        v18 = *(int32_t *)(v2 + 16);
        goto lab_0xc234_2;
    }
  lab_0xc234_2:;
    int32_t v24 = *(int32_t *)(v2 + 12); // 0xc234
    v19 = v24;
    v20 = v18;
    if (v24 > v18) {
        // 0xc464
        return error((int32_t)"starting year greater than ending year");
    }
    goto lab_0xc254;
  lab_0xc254:
    // 0xc254
    if (*(char *)&v7 == 0) {
        // 0xc264
        *(int32_t *)(v2 + 20) = 0;
    } else {
        // 0xc270
        if (v19 == v20) {
            // 0xc464
            return error((int32_t)"typed single year");
        }
        // 0xc290
        *(int32_t *)(v2 + 20) = memcheck(icpyalloc((char *)a4));
    }
    int32_t v25 = memcheck(icpyalloc((char *)a6)); // 0xc2bc
    int32_t v26 = byword(v25, (char (**)[5])&g5); // 0xc2d0
    if (v26 != 0) {
        // 0xc2e0
        *(int32_t *)(v2 + 36) = 2;
        *(int32_t *)(v2 + 44) = *(int32_t *)(v26 + 4);
        int32_t v27 = *(int32_t *)(4 * *v3 + (int32_t)&g9 + 48); // 0xc300
        *(int32_t *)(v2 + 40) = v27;
        // 0xc464
        return ifree(v25);
    }
    char * str4 = (char *)v25;
    char * found_char_pos = strchr(str4, 60); // 0xc314
    char * str5; // 0xbedc
    char * v28; // 0xbedc
    int32_t v29; // 0xbedc
    if (found_char_pos == NULL) {
        char * found_char_pos2 = strchr(str4, 62); // 0xc338
        int32_t * v30 = (int32_t *)(v2 + 36);
        if (found_char_pos2 == NULL) {
            // 0xc360
            *v30 = 0;
            str5 = str4;
            v29 = v25;
            goto lab_0xc3e4;
        } else {
            // 0xc348
            *v30 = 1;
            v28 = found_char_pos2;
            goto lab_0xc36c;
        }
    } else {
        // 0xc324
        *(int32_t *)(v2 + 36) = 2;
        v28 = found_char_pos;
        goto lab_0xc36c;
    }
  lab_0xc36c:;
    int32_t v31 = (int32_t)v28;
    *v28 = 0;
    if (*(char *)(v31 + 1) != 61) {
        // 0xc390
        error((int32_t)"invalid day of month");
        // 0xc464
        return ifree(v25);
    }
    int32_t v32 = byword(v25, (char (**)[5])&g4); // 0xc3b4
    if (v32 == 0) {
        // 0xc3c4
        error((int32_t)"invalid weekday name");
        // 0xc464
        return ifree(v25);
    }
    int32_t v33 = v31 + 2; // 0xc380
    *(int32_t *)(v2 + 44) = *(int32_t *)(v32 + 4);
    str5 = (char *)v33;
    v29 = v33;
    goto lab_0xc3e4;
  lab_0xc3e4:
    // 0xc3e4
    if (sscanf(str5, (char *)scheck(v29, "%d")) != 1) {
        // 0xc444
        error((int32_t)"invalid day of month");
        // 0xc464
        return ifree(v25);
    }
    int32_t v34 = *(int32_t *)(v2 + 40); // 0xc418
    if (v34 < 1) {
        // 0xc444
        error((int32_t)"invalid day of month");
        // 0xc464
        return ifree(v25);
    }
    // 0xc424
    if (v34 <= *(int32_t *)(4 * *v3 + (int32_t)&g9 + 48)) {
        // 0xc464
        return ifree(v25);
    }
    // 0xc444
    error((int32_t)"invalid day of month");
    // 0xc464
    return ifree(v25);
}

// Address range: 0xc46c - 0xc4c4
int32_t convert(int32_t result, int32_t * a2) {
    int32_t v1 = 24; // 0xc46c
    int32_t v2 = 0; // 0xc4a8
    *(char *)(v2 + (int32_t)a2) = (char)(result >> v1);
    v2++;
    v1 -= 8;
    while (v2 < 4) {
        // 0xc48c
        *(char *)(v2 + (int32_t)a2) = (char)(result >> v1);
        v2++;
        v1 -= 8;
    }
    // 0xc4b8
    return result;
}

// Address range: 0xc4c4 - 0xc534
int32_t convert64(int64_t a1, int32_t a2, int32_t * a3) {
    uint64_t v1 = 0x100000000 * a1 >> 32; // 0xc4f0
    int32_t v2 = v1; // 0xc4f0
    int32_t v3 = 0; // 0xc518
    uint32_t v4 = 56;
    uint32_t v5 = v4 - 32; // 0xc4f8
    int32_t v6 = v2 << 32 - v4 | (int32_t)(v1 / 0x100000000) >> v4; // 0xc500
    char v7 = v6; // 0xc504
    if (v5 >= 0) {
        // 0xc508
        v7 = v6 | v2 >> v5;
    }
    // 0xc50c
    *(char *)(v3 + (int32_t)a3) = v7;
    v3++;
    int32_t v8 = v4 - 8; // 0xc524
    while (v3 < 8) {
        // 0xc4e4
        v4 = v8;
        v5 = v4 - 32;
        v6 = v2 << 32 - v4 | (int32_t)(v1 / 0x100000000) >> v4;
        v7 = v6;
        if (v5 >= 0) {
            // 0xc508
            v7 = v6 | v2 >> v5;
        }
        // 0xc50c
        *(char *)(v3 + (int32_t)a3) = v7;
        v3++;
        v8 = v4 - 8;
    }
    // 0xc528
    return -32;
}

// Address range: 0xc534 - 0xc578
int32_t puttzcode(int32_t a1, int32_t stream) {
    // 0xc534
    int32_t data; // bp-12, 0xc534
    convert(a1, &data);
    return fwrite(&data, 4, 1, (struct _IO_FILE *)stream);
}

// Address range: 0xc578 - 0xc5bc
int32_t puttzcode64(int32_t a1, int32_t a2, int32_t stream) {
    // 0xc578
    int32_t data; // bp-16, 0xc578
    convert64((int64_t)(int32_t)(a1 >> 31), a1, &data);
    return fwrite(&data, 8, 1, (struct _IO_FILE *)stream);
}

// Address range: 0xc630 - 0xc68c
int32_t is32(int32_t a1, int32_t a2) {
    uint32_t v1 = (uint32_t)a1 % 2; // 0xc650
    if ((v1 == 0) >= (a1 > -1)) {
        // 0xc658
        if ((v1 != 0) >= (a1 < 0)) {
            // 0xc67c
            return 1;
        }
    }
    // 0xc67c
    return 0;
}

// Address range: 0xc68c - 0xdbb0
int32_t writezone(int32_t a1, int32_t a2) {
    // 0xc68c
    int32_t v1; // bp-40, 0xc68c
    int32_t v2 = &v1; // 0xc6a4
    *(int32_t *)(v2 - 0x421c) = a1;
    *(int32_t *)(v2 - 0x4220) = a2;
    int32_t nmemb = g40; // 0xc6c4
    int32_t v3 = nmemb; // 0xc6cc
    if (nmemb >= 2) {
        // 0xc6d0
        qsort(&g48, nmemb, 16, (int32_t (*)(int32_t *, int32_t *))0xc5bc);
        v3 = g40;
    }
    int32_t v4 = 0; // 0xc72c
    if (v3 > 0) {
        uint64_t v5 = *(int64_t *)&g33; // 0xc750
        uint32_t v6 = (int32_t)(v5 / 0x100000000); // 0xc750
        int32_t v7 = 0; // 0xc710
        uint64_t v8 = *(int64_t *)(16 * v7 + (int32_t)&g48); // 0xc744
        v4 = v7;
        while (((v8 ^ v5) % 2 != 0) < ((int32_t)(v8 / 0x100000000) < v6)) {
            // 0xc70c
            v7++;
            v4 = v7;
            if (v7 >= v3) {
                // break -> 0xc760
                break;
            }
            v8 = *(int64_t *)(16 * v7 + (int32_t)&g48);
            v4 = v7;
        }
    }
    int32_t v9 = v4; // 0xc770
    int32_t v10 = v4; // 0xc770
    if (v4 < v3 == *(char *)&g50 == 0) {
        v10 = v9;
        while (*(char *)(16 * v9 + (int32_t)&g48 + 8) == 0) {
            // 0xc778
            v9++;
            v10 = v9;
            if (v9 >= v3) {
                // break -> 0xc7c4
                break;
            }
            v10 = v9;
        }
    }
    int32_t v11 = 0; // 0xc9a8
    int32_t v12 = v10; // 0xc9a8
    int32_t v13; // 0xc68c
    int32_t v14; // 0xc68c
    int32_t v15; // 0xc68c
    int32_t v16; // 0xc68c
    int32_t v17; // 0xc68c
    int32_t v18; // 0xc68c
    int32_t v19; // 0xc68c
    int32_t v20; // 0xc68c
    int32_t v21; // 0xcb18
    int32_t v22; // 0xc68c
    int32_t v23; // bp-10880, 0xc68c
    int32_t v24; // 0xc68c
    int32_t v25; // 0xc68c
    int32_t v26; // 0xc68c
    int32_t v27; // 0xc68c
    if (v10 < v3) {
        while (true) {
          lab_0xc7c8_2:
            // 0xc7c8
            v26 = v11;
            v14 = 16 * v12;
            v15 = v14 + (int32_t)&g48;
            if (v26 == 0) {
                // 0xc7c8
                v17 = v14 + (int32_t)&g48 + 8;
                v16 = 0;
                goto lab_0xc950;
            } else {
                uint64_t v28 = *(int64_t *)v15; // 0xc7e8
                int32_t v29 = 16 * v26;
                char * v30 = (char *)(v29 + (int32_t)&g48 - 8); // 0xc80c
                unsigned char v31 = *v30; // 0xc80c
                int32_t v32 = *(int32_t *)(4 * (int32_t)v31 + (int32_t)&g49); // 0xc81c
                uint64_t v33 = *(int64_t *)(v29 + (int32_t)&g48 - 16); // 0xc848
                int32_t v34 = 0; // 0xc854
                if (v26 != 1) {
                    unsigned char v35 = *(char *)(v29 + (int32_t)&g48 - 24); // 0xc878
                    v34 = v35;
                }
                uint32_t v36 = (int32_t)(v28 / 0x100000000); // 0xc7e8
                uint32_t v37 = v32 + v36; // 0xc828
                uint32_t v38 = *(int32_t *)(4 * v34 + (int32_t)&g49); // 0xc890
                uint32_t v39 = v38 + (int32_t)(v33 / 0x100000000); // 0xc89c
                int32_t v40 = v14 + (int32_t)&g48 + 8;
                char v41 = *(char *)v40;
                if ((((v32 >> 31) - (int32_t)v28 + (int32_t)v33 + (int32_t)(v37 < v36) + (int32_t)(v38 < 0) + (int32_t)(v39 < v38)) % 2 != 0) < (v39 < v37)) {
                    // 0xc904
                    v17 = v40;
                    v16 = v29;
                    if (v31 == v41) {
                        goto lab_0xc988;
                    } else {
                        goto lab_0xc950;
                    }
                } else {
                    // 0xc8b0
                    *v30 = v41;
                    v24 = v26;
                    goto lab_0xc988;
                }
            }
        }
      lab_0xc9ac_2:
        // 0xc9ac
        g40 = v25;
        v13 = v25;
        if (v25 > 0) {
            for (int32_t i = 0; i < g40; i++) {
                int32_t v42 = 16 * i; // 0xc9cc
                uint64_t v43 = *(int64_t *)(v42 + (int32_t)&g48); // 0xc9d4
                int32_t v44 = 8 * i + v2; // 0xc9e8
                *(int32_t *)(v44 - 0x25a8) = (int32_t)(v43 / 0x100000000);
                *(int32_t *)(v44 - 0x25a4) = (int32_t)v43;
                char v45 = *(char *)(v42 + (int32_t)&g48 + 8); // 0xca0c
                *(char *)(i + (int32_t)&v23) = v45;
            }
            // 0xcb10
            v18 = g40;
            v27 = 0;
            v13 = g40;
            if (g40 > 0) {
                while (true) {
                  lab_0xca48:;
                    int32_t v46 = *(int32_t *)((int32_t)&g106 & (int32_t)&g108 | (int32_t)&g1); // 0xca50
                    int32_t v47 = 8 * v27 + v2;
                    int32_t v48 = v47 - 0x25a8;
                    int64_t * v49 = (int64_t *)v48;
                    int32_t v50 = v46; // 0xca54
                    v50--;
                    v19 = v18;
                    while (v50 >= 0) {
                        uint64_t v51 = *v49; // 0xca70
                        int32_t v52 = v51; // 0xca70
                        uint64_t v53 = *(int64_t *)(8 * v50 + (int32_t)&g55); // 0xca84
                        uint32_t v54 = (int32_t)(v53 / 0x100000000); // 0xca84
                        uint32_t v55 = *(int32_t *)(4 * v50 + (int32_t)&g56); // 0xca90
                        if ((((int32_t)v53 - v52 + (int32_t)(v55 < 0) + (int32_t)(v55 > v54)) % 2 != 0) < (v54 - v55 < (int32_t)(v51 / 0x100000000))) {
                            // 0xcab0
                            *(int32_t *)v48 = tadd(v51 / 0x100000000, v52, v55);
                            *(int32_t *)(v47 - 0x25a4) = v52;
                            v19 = g40;
                            goto lab_0xcb0c;
                        }
                        v50--;
                        v19 = v18;
                    }
                    goto lab_0xcb0c;
                }
              lab_0xcb24_2:;
                int32_t v56 = *(int32_t *)((int32_t)&g106 & 0xffff | (int32_t)&g1); // 0xcb44
                v20 = v56;
                v22 = v21;
                if (v21 >= 1) {
                    int32_t v57; // 0xc68c
                    int32_t v58; // 0xcb78
                    uint64_t v59 = *(int64_t *)(v58 + 8 * v57); // 0xcb80
                    // 0xcb64
                    while (is32((int32_t)(v59 / 0x100000000), (int32_t)v59) == 0) {
                        // 0xcb58
                        int32_t v60; // 0xc68c
                        int32_t v61 = v60 - 1; // 0xcb58
                        v57 = v61;
                        int32_t v62 = v61; // 0xcb60
                        if (v60 < 2) {
                            // break -> 0xcb9c
                            break;
                        }
                        v60 = v57;
                        v59 = *(int64_t *)(v58 + 8 * v60);
                        v62 = v60;
                    }
                    // 0xcb9c
                    v20 = v56;
                    v22 = v57;
                    if (v57 >= 1) {
                        int32_t v63 = v2 - 0x25a8; // 0xcbd8
                        int32_t v64 = 0;
                        int32_t v65 = v57;
                        uint64_t v66 = *(int64_t *)(v63 + 8 * v64); // 0xcbe0
                        v20 = v56;
                        v22 = v65;
                        while (is32((int32_t)(v66 / 0x100000000), (int32_t)v66) == 0) {
                            int32_t v67 = v65 - 1; // 0xcba0
                            v20 = v56;
                            v22 = v67;
                            if (v65 < 2) {
                                // break -> 0xcbfc
                                break;
                            }
                            v64++;
                            v65 = v67;
                            v66 = *(int64_t *)(v63 + 8 * v64);
                            v20 = v56;
                            v22 = v65;
                        }
                    }
                }
                goto lab_0xcbfc;
            } else {
                goto lab_0xcb24;
            }
        } else {
            goto lab_0xcb24;
        }
    } else {
        // 0xc9ac
        g40 = 0;
        v13 = 0;
        goto lab_0xcb24;
    }
  lab_0xd518:;
    // 0xd518
    int32_t v68; // 0xc68c
    int32_t v69; // 0xc68c
    unsigned char v70 = *(char *)(v68 + v69); // 0xd52c
    char * v71; // 0xc68c
    *v71 = (char)*(int32_t *)(v2 - 0x411c + 4 * (int32_t)v70);
    struct _IO_FILE * stream; // 0xc68c
    int32_t data; // bp-10881, 0xc68c
    fwrite(&data, 1, 1, stream);
    int32_t v72 = v68 + 1; // 0xd584
    v68 = v72;
    int32_t v73; // 0xcf60
    if (v72 < v73) {
        goto lab_0xd518;
    } else {
        goto lab_0xd75c;
    }
  lab_0xd908:;
    // 0xd908
    int32_t v74; // 0xc68c
    int32_t v75 = v74;
    int32_t v76; // 0xc68c
    int32_t v77; // 0xc68c
    int32_t v78; // 0xc68c
    if (v78 == 1) {
        // 0xd918
        puttzcode(v75, v76);
    } else {
        // 0xd92c
        puttzcode64(v75, v77, v76);
    }
    // 0xd93c
    int32_t v79; // 0xc68c
    puttzcode(*(int32_t *)(4 * v79 + (int32_t)&g56), v76);
    int32_t v80 = v79 + 1; // 0xd954
    int32_t v81 = v80; // 0xd964
    int32_t v82; // 0xcf7c
    if (v80 >= v82) {
        // break -> 0xda20
        goto lab_0xda20;
    }
    goto lab_0xd7a8;
  lab_0xd800:;
    int32_t v96 = 0;
    int32_t v97 = v96; // 0xd838
    while (*(char *)(v96 + (int32_t)&g50) != 0) {
        int32_t v98 = v96 + 1; // 0xd808
        int32_t v99 = v98; // 0xd81c
        v97 = 0;
        if (v98 >= g41) {
            // break -> 0xd8bc
            break;
        }
        v96 = v99;
        v97 = v96;
    }
    int64_t v94 = *(int64_t *)(8 * v79 + (int32_t)&g55); // 0xc68c
    int32_t v95 = v97; // 0xc68c
    goto lab_0xd8bc;
  lab_0xd8bc:;
    int32_t v100 = v94; // 0xd8cc
    int32_t v101 = *(int32_t *)(4 * v95 + (int32_t)&g49); // 0xd8d8
    v74 = tadd(v94 >> 32, v100, -v101);
    v77 = v100;
    goto lab_0xd908;
  lab_0xd75c:;
    // 0xd75c
    int32_t v102; // 0xc68c
    int32_t v103; // 0xc68c
    int32_t * v104; // 0xc68c
    int32_t * v105; // 0xc68c
    int32_t * v106; // 0xc68c
    if (g41 > 0) {
        int32_t v107 = 0;
        int32_t v108 = 4 * v107; // 0xd5a8
        unsigned char c; // 0xd654
        uint32_t v109; // 0xd5f4
        char v110; // 0xd624
        unsigned char v111; // 0xd638
        unsigned char v112; // 0xd724
        uint32_t v113; // 0xd67c
        unsigned char v114; // 0xd6ac
        int32_t v115; // 0xd6cc
        unsigned char v116; // 0xd6e4
        if (*(int32_t *)(v108 + v102) != 0) {
            // 0xd5c4
            puttzcode(*(int32_t *)(v108 + (int32_t)&g49), v76);
            if (*v104 == 0) {
                // 0xd64c
                c = *(char *)(v107 + (int32_t)&g50);
                fputc((int32_t)c, stream);
            } else {
                // 0xd5f0
                v109 = *v105;
                if (v109 < *v106) {
                    // 0xd608
                    *v105 = v109 + 1;
                    v110 = *(char *)(v107 + (int32_t)&g50);
                    *(char *)v109 = v110;
                } else {
                    // 0xd630
                    v111 = *(char *)(v107 + (int32_t)&g50);
                    __fputc_unlocked((int32_t)v111, stream);
                }
            }
            // 0xd664
            if (*v104 == 0) {
                // 0xd71c
                v112 = *(char *)(v107 + (int32_t)&g51);
                fputc(*(int32_t *)(4 * (int32_t)v112 + v103) % 256, stream);
            } else {
                // 0xd678
                v113 = *v105;
                if (v113 < *v106) {
                    // 0xd690
                    *v105 = v113 + 1;
                    v114 = *(char *)(v107 + (int32_t)&g51);
                    v115 = *(int32_t *)(4 * (int32_t)v114 + v103);
                    *(char *)v113 = (char)v115;
                } else {
                    // 0xd6dc
                    v116 = *(char *)(v107 + (int32_t)&g51);
                    __fputc_unlocked(*(int32_t *)(4 * (int32_t)v116 + v103) % 256, stream);
                }
            }
        }
        int32_t v117 = v107 + 1; // 0xd758
        while (v117 < g41) {
            // 0xd5a0
            v107 = v117;
            v108 = 4 * v107;
            if (*(int32_t *)(v108 + v102) != 0) {
                // 0xd5c4
                puttzcode(*(int32_t *)(v108 + (int32_t)&g49), v76);
                if (*v104 == 0) {
                    // 0xd64c
                    c = *(char *)(v107 + (int32_t)&g50);
                    fputc((int32_t)c, stream);
                } else {
                    // 0xd5f0
                    v109 = *v105;
                    if (v109 < *v106) {
                        // 0xd608
                        *v105 = v109 + 1;
                        v110 = *(char *)(v107 + (int32_t)&g50);
                        *(char *)v109 = v110;
                    } else {
                        // 0xd630
                        v111 = *(char *)(v107 + (int32_t)&g50);
                        __fputc_unlocked((int32_t)v111, stream);
                    }
                }
                // 0xd664
                if (*v104 == 0) {
                    // 0xd71c
                    v112 = *(char *)(v107 + (int32_t)&g51);
                    fputc(*(int32_t *)(4 * (int32_t)v112 + v103) % 256, stream);
                } else {
                    // 0xd678
                    v113 = *v105;
                    if (v113 < *v106) {
                        // 0xd690
                        *v105 = v113 + 1;
                        v114 = *(char *)(v107 + (int32_t)&g51);
                        v115 = *(int32_t *)(4 * (int32_t)v114 + v103);
                        *(char *)v113 = (char)v115;
                    } else {
                        // 0xd6dc
                        v116 = *(char *)(v107 + (int32_t)&g51);
                        __fputc_unlocked(*(int32_t *)(4 * (int32_t)v116 + v103) % 256, stream);
                    }
                }
            }
            // 0xd758
            v117 = v107 + 1;
        }
    }
    int32_t data2; // bp-16960, 0xc68c
    char v118; // 0xc68c
    int32_t nmemb2; // 0xd3ac
    if (v118 != 0) {
        // 0xd77c
        fwrite(&data2, 1, nmemb2, stream);
    }
    // 0xd79c
    int32_t v119; // 0xc68c
    v81 = v119;
    int64_t v85; // 0xc68c
    uint32_t v86; // 0xc68c
    if (v119 < v82) {
        while (true) {
          lab_0xd7a8:
            // 0xd7a8
            v79 = v81;
            if (*(char *)(v79 + (int32_t)&g57) == 0) {
                uint64_t v83 = *(int64_t *)(8 * v79 + (int32_t)&g55); // 0xd904
                v74 = v83 / 0x100000000;
                v77 = v83;
                goto lab_0xd908;
            } else {
                // 0xd7bc
                if (g40 == 0) {
                    goto lab_0xd800;
                } else {
                    uint64_t v84 = *(int64_t *)(8 * v79 + (int32_t)&g55); // 0xd7e0
                    if (((v84 ^ v85) % 2 != 0) < ((int32_t)(v84 / 0x100000000) < v86)) {
                        goto lab_0xd800;
                    } else {
                        // 0xd84c
                        if (g40 > 1) {
                            int32_t v87; // 0xc68c
                            int32_t v88 = v87;
                            int32_t v89; // 0xc68c
                            uint64_t v90 = *(int64_t *)(8 * v88 + v89); // 0xd88c
                            uint32_t v91; // 0xc68c
                            while (((v90 ^ v84) % 2 != 0) >= (v91 < (int32_t)(v90 / 0x100000000))) {
                                int32_t v92 = v88 + 1; // 0xd848
                                v87 = v92;
                                int32_t v93; // 0xd7c4
                                if (v92 >= v93) {
                                    // break -> 0xd89c
                                    break;
                                }
                                v88 = v87;
                                v90 = *(int64_t *)(8 * v88 + v89);
                            }
                        }
                        // 0xd89c
                        v94 = v84;
                        v95 = (int32_t)*(char *)v69;
                        goto lab_0xd8bc;
                    }
                }
            }
        }
    }
  lab_0xda20:
    // 0xda20
    if (g41 > 0) {
        int32_t v120 = 0;
        unsigned char c2; // 0xda0c
        uint32_t v121; // 0xd9ac
        char v122; // 0xd9dc
        unsigned char v123; // 0xd9f0
        if (*(int32_t *)(4 * v120 + v102) != 0) {
            // 0xd994
            if (*v104 == 0) {
                // 0xda04
                c2 = *(char *)(v120 + (int32_t)&g52);
                fputc((int32_t)c2, stream);
            } else {
                // 0xd9a8
                v121 = *v105;
                if (v121 < *v106) {
                    // 0xd9c0
                    *v105 = v121 + 1;
                    v122 = *(char *)(v120 + (int32_t)&g52);
                    *(char *)v121 = v122;
                } else {
                    // 0xd9e8
                    v123 = *(char *)(v120 + (int32_t)&g52);
                    __fputc_unlocked((int32_t)v123, stream);
                }
            }
        }
        int32_t v124 = v120 + 1; // 0xda1c
        while (v124 < g41) {
            // 0xd970
            v120 = v124;
            if (*(int32_t *)(4 * v120 + v102) != 0) {
                // 0xd994
                if (*v104 == 0) {
                    // 0xda04
                    c2 = *(char *)(v120 + (int32_t)&g52);
                    fputc((int32_t)c2, stream);
                } else {
                    // 0xd9a8
                    v121 = *v105;
                    if (v121 < *v106) {
                        // 0xd9c0
                        *v105 = v121 + 1;
                        v122 = *(char *)(v120 + (int32_t)&g52);
                        *(char *)v121 = v122;
                    } else {
                        // 0xd9e8
                        v123 = *(char *)(v120 + (int32_t)&g52);
                        __fputc_unlocked((int32_t)v123, stream);
                    }
                }
            }
            // 0xda1c
            v124 = v120 + 1;
        }
        // 0xdaec
        if (g41 > 0) {
            int32_t v125 = 0;
            unsigned char c3; // 0xdad8
            uint32_t v126; // 0xda78
            char v127; // 0xdaa8
            unsigned char v128; // 0xdabc
            if (*(int32_t *)(4 * v125 + v102) != 0) {
                // 0xda60
                if (*v104 == 0) {
                    // 0xdad0
                    c3 = *(char *)(v125 + (int32_t)&g53);
                    fputc((int32_t)c3, stream);
                } else {
                    // 0xda74
                    v126 = *v105;
                    if (v126 < *v106) {
                        // 0xda8c
                        *v105 = v126 + 1;
                        v127 = *(char *)(v125 + (int32_t)&g53);
                        *(char *)v126 = v127;
                    } else {
                        // 0xdab4
                        v128 = *(char *)(v125 + (int32_t)&g53);
                        __fputc_unlocked((int32_t)v128, stream);
                    }
                }
            }
            int32_t v129 = v125 + 1; // 0xdae8
            while (v129 < g41) {
                // 0xda3c
                v125 = v129;
                if (*(int32_t *)(4 * v125 + v102) != 0) {
                    // 0xda60
                    if (*v104 == 0) {
                        // 0xdad0
                        c3 = *(char *)(v125 + (int32_t)&g53);
                        fputc((int32_t)c3, stream);
                    } else {
                        // 0xda74
                        v126 = *v105;
                        if (v126 < *v106) {
                            // 0xda8c
                            *v105 = v126 + 1;
                            v127 = *(char *)(v125 + (int32_t)&g53);
                            *(char *)v126 = v127;
                        } else {
                            // 0xdab4
                            v128 = *(char *)(v125 + (int32_t)&g53);
                            __fputc_unlocked((int32_t)v128, stream);
                        }
                    }
                }
                // 0xdae8
                v129 = v125 + 1;
            }
        }
    }
    int32_t v130 = v78 + 1; // 0xdb08
    int32_t v131 = v130; // 0xdb20
    if (v130 >= 3) {
        // break -> 0xdb24
        goto lab_0xdb24;
    }
    goto lab_0xcecc;
  lab_0xcb0c:
    // 0xcb0c
    v21 = v19;
    int32_t v176 = v27 + 1; // 0xcb0c
    v18 = v21;
    v27 = v176;
    if (v176 >= v21) {
        // break -> 0xcb24
        goto lab_0xcb24_2;
    }
    goto lab_0xca48;
  lab_0xc950:;
    int32_t v177 = *(int32_t *)v15; // 0xc980
    int32_t v178 = *(int32_t *)(v14 + (int32_t)&g48 + 4); // 0xc980
    int32_t v179 = *(int32_t *)v17; // 0xc980
    int32_t v180 = *(int32_t *)(v14 + (int32_t)&g48 + 12); // 0xc980
    *(int32_t *)(v16 + (int32_t)&g48) = v177;
    *(int32_t *)(v16 + (int32_t)&g48 + 4) = v178;
    *(int32_t *)(v16 + (int32_t)&g48 + 8) = v179;
    *(int32_t *)(v16 + (int32_t)&g48 + 12) = v180;
    v24 = v26 + 1;
    goto lab_0xc988;
  lab_0xc988:
    // 0xc988
    v25 = v24;
    int32_t v181 = v12 + 1; // 0xc98c
    v11 = v25;
    v12 = v181;
    if (v181 >= g40) {
        // break -> 0xc9ac
        goto lab_0xc9ac_2;
    }
    goto lab_0xc7c8_2;
  lab_0xcb24:;
    int32_t v182 = *(int32_t *)((int32_t)&g106 & 0xffff | (int32_t)&g1); // 0xcb44
    v20 = v182;
    v22 = v13;
    goto lab_0xcbfc;
  lab_0xcbfc:;
    int32_t v133 = 0; // 0xcc08
    int32_t v135 = v20; // 0xcc08
    if (v20 >= 1) {
        int32_t v183 = v20;
        uint64_t v184 = *(int64_t *)(8 * v183 + (int32_t)&g55 - 8); // 0xcc20
        int32_t v185 = v183; // 0xcc38
        while (is32((int32_t)(v184 / 0x100000000), (int32_t)v184) == 0) {
            int32_t v186 = v183 - 1; // 0xcc00
            v185 = v186;
            if (v183 < 2) {
                // break -> 0xcc3c
                break;
            }
            v183 = v186;
            v184 = *(int64_t *)(8 * v183 + (int32_t)&g55 - 8);
            v185 = v183;
        }
        int32_t v187 = 0; // 0xcc5c
        v133 = 0;
        v135 = v185;
        if (v185 >= 1) {
            int32_t v188 = v185;
            uint64_t v189 = *(int64_t *)(8 * v187 + (int32_t)&g55); // 0xcc78
            v133 = v187;
            v135 = v188;
            while (is32((int32_t)(v189 / 0x100000000), (int32_t)v189) == 0) {
                int32_t v190 = v188 - 1; // 0xcc40
                int32_t v191 = v187 + 1; // 0xcc4c
                v187 = v191;
                v133 = v191;
                v135 = v190;
                if (v188 < 2) {
                    // break -> 0xcc94
                    break;
                }
                v188 = v190;
                v189 = *(int64_t *)(8 * v187 + (int32_t)&g55);
                v133 = v187;
                v135 = v188;
            }
        }
    }
    int32_t len = strlen(g60); // 0xccb0
    char * str3; // 0xc68c
    int32_t len2 = strlen(str3); // 0xccc8
    int32_t str4 = memcheck(irealloc((int32_t)g81, len + 2 + len2)); // 0xccec
    *(int32_t *)&g81 = str4;
    sprintf((char *)str4, "%s/%s", g60, str3);
    if (itsdir((int32_t)g81) == 0) {
        // 0xcd58
        if (remove(g81) != 0) {
            // 0xcd78
            if (*__errno_location() != 2) {
                int32_t err_num = *__errno_location(); // 0xcd94
                fprintf(g21, "%s: Can't remove %s: %s\n", g39, g81, strerror(err_num));
                exit(1);
                // UNREACHABLE
            }
        }
    }
    struct _IO_FILE * file = fopen(g81, "wb"); // 0xce00
    stream = file;
    if (file == NULL) {
        // 0xce10
        if (mkdirs((int32_t)g81) != 0) {
            // 0xce30
            exit(1);
            // UNREACHABLE
        }
        struct _IO_FILE * file2 = fopen(g81, "wb"); // 0xce50
        stream = file2;
        if (file2 == NULL) {
            int32_t err_num2 = *__errno_location(); // 0xce68
            fprintf(g21, "%s: Can't create %s: %s\n", g39, g81, strerror(err_num2));
            exit(1);
            // UNREACHABLE
        }
    }
    // 0xcebc
    v76 = (int32_t)stream;
    v102 = v2 - 0x3d1c;
    v69 = &v23;
    v103 = v2 - 0x41e4;
    int32_t v164 = &data2;
    v71 = (char *)(v2 - 0x2a59);
    v104 = (int32_t *)(v76 + 72);
    v105 = (int32_t *)(v76 + 16);
    v106 = (int32_t *)(v76 + 28);
    v86 = (int32_t)(v85 / 0x100000000);
    v131 = 1;
    while (true) {
      lab_0xcecc:
        // 0xcecc
        v78 = v131;
        int32_t v132 = v22; // 0xced8
        v119 = v133;
        int32_t v134 = v135; // 0xced8
        if (v78 != 1) {
            // 0xcf10
            v132 = g40;
            v134 = *(int32_t *)((int32_t)&g106 & 0xffff | (int32_t)&g1);
            v119 = 0;
        }
        int32_t v136 = v132;
        int32_t v137 = 0;
        int32_t v138 = 0; // 0xcfe8
        if (g41 > 0) {
            *(int32_t *)(4 * v138 + v102) = (int32_t)(v136 == g40);
            int32_t v139 = v138 + 1; // 0xcfd4
            v138 = v139;
            while (v139 < g41) {
                // 0xcf90
                *(int32_t *)(4 * v138 + v102) = (int32_t)(v136 == g40);
                v139 = v138 + 1;
                v138 = v139;
            }
        }
        // 0xcfec
        v73 = v136 + v137;
        if (v136 == 0) {
            // 0xcffc
            if (g41 != 0) {
                // 0xd010
                *(int32_t *)(v2 - 0x3d20 + 4 * g41) = 1;
            }
        } else {
            int32_t v140 = v137 - 1; // 0xd04c
            int32_t v141 = v140; // 0xd0a4
            if (v140 < v73) {
                uint32_t v142 = v141;
                unsigned char v143; // 0xd070
                if (v142 >= 0) {
                    // 0xd05c
                    v143 = *(char *)(v142 + v69);
                    *(int32_t *)(4 * (int32_t)v143 + v102) = 1;
                }
                int32_t v144 = v142 + 1; // 0xd094
                while (v144 < v73) {
                    // 0xd054
                    v142 = v144;
                    if (v142 >= 0) {
                        // 0xd05c
                        v143 = *(char *)(v142 + v69);
                        *(int32_t *)(4 * (int32_t)v143 + v102) = 1;
                    }
                    // 0xd094
                    v144 = v142 + 1;
                }
            }
            if (v137 == 0) {
                // 0xd0b8
                *(int32_t *)v102 = 1;
            }
        }
        int32_t v145 = 0; // 0xd140
        int32_t v146 = 0; // 0xd140
        int32_t v147 = 0; // 0xd140
        if (g41 > 0) {
            int32_t v148 = 4 * v145 + v2; // 0xd0e8
            int32_t v149 = *(int32_t *)(v148 - 0x3d1c); // 0xd0f0
            int32_t v150 = v146 + (int32_t)(v149 != 0);
            *(int32_t *)(v148 - 0x411c) = v149 == 0 ? -1 : v146;
            int32_t v151 = v145 + 1; // 0xd12c
            v145 = v151;
            v146 = v150;
            v147 = v150;
            while (v151 < g41) {
                // 0xd0d8
                v148 = 4 * v145 + v2;
                v149 = *(int32_t *)(v148 - 0x3d1c);
                v150 = v146 + (int32_t)(v149 != 0);
                *(int32_t *)(v148 - 0x411c) = v149 == 0 ? -1 : v146;
                v151 = v145 + 1;
                v145 = v151;
                v146 = v150;
                v147 = v150;
            }
        }
        // 0xd170
        v82 = v134 + v119;
        int32_t v152 = 0; // 0xd16c
        *(int32_t *)(4 * v152 + v103) = -1;
        v152++;
        while (v152 == 49 || v152 < 49) {
            // 0xd14c
            *(int32_t *)(4 * v152 + v103) = -1;
            v152++;
        }
        // 0xd2c4
        v118 = 0;
        if (g41 > 0) {
            char v153 = 0;
            int32_t v154 = 0;
            int32_t v155 = g41; // 0xd1ac
            char v156 = v153; // 0xd1ac
            char v157; // 0xc68c
            int32_t v158; // 0xc68c
            int32_t v159; // 0xc68c
            char * v160; // 0xd1bc
            int32_t v161; // 0xd1bc
            int32_t str; // 0xd200
            uint32_t v162; // 0xd23c
            char * str2; // 0xd270
            int32_t strcmp_rc; // 0xd224
            int32_t v163; // 0xd238
            if (*(int32_t *)(4 * v154 + v102) != 0) {
                // 0xd1b4
                v160 = (char *)(v154 + (int32_t)&g51);
                v161 = (int32_t)*v160;
                v155 = g41;
                v156 = v153;
                if (*(int32_t *)(4 * v161 + v103) < 0) {
                    // 0xd1e8
                    str = v161 + (int32_t)&g54;
                    v162 = (int32_t)v153;
                    v159 = 0;
                    if (v153 != 0) {
                        // 0xd20c
                        v158 = 0;
                        strcmp_rc = strcmp((char *)(v158 + v164), (char *)str);
                        v159 = v158;
                        while (strcmp_rc != 0) {
                            // 0xd238
                            v163 = v158 + 1;
                            v159 = v163;
                            if (v163 >= v162) {
                                // break -> 0xd248
                                break;
                            }
                            v158 = v163;
                            strcmp_rc = strcmp((char *)(v158 + v164), (char *)str);
                            v159 = v158;
                        }
                    }
                    // 0xd248
                    v157 = v153;
                    if (v159 == v162) {
                        // 0xd254
                        str2 = (char *)str;
                        strcpy((char *)(v162 + v164), str2);
                        v157 = v153 + 1 + (char)strlen(str2);
                    }
                    // 0xd298
                    *(int32_t *)(4 * (int32_t)*v160 + v103) = v159;
                    v155 = g41;
                    v156 = v157;
                }
            }
            int32_t v165 = v154 + 1; // 0xd2c0
            v118 = v156;
            while (v165 < v155) {
                // 0xd18c
                v153 = v156;
                v154 = v165;
                int32_t v166 = v155;
                v155 = v166;
                v156 = v153;
                if (*(int32_t *)(4 * v154 + v102) != 0) {
                    // 0xd1b4
                    v160 = (char *)(v154 + (int32_t)&g51);
                    v161 = (int32_t)*v160;
                    v155 = v166;
                    v156 = v153;
                    if (*(int32_t *)(4 * v161 + v103) < 0) {
                        // 0xd1e8
                        str = v161 + (int32_t)&g54;
                        v162 = (int32_t)v153;
                        v159 = 0;
                        if (v153 != 0) {
                            // 0xd20c
                            v158 = 0;
                            strcmp_rc = strcmp((char *)(v158 + v164), (char *)str);
                            v159 = v158;
                            while (strcmp_rc != 0) {
                                // 0xd238
                                v163 = v158 + 1;
                                v159 = v163;
                                if (v163 >= v162) {
                                    // break -> 0xd248
                                    break;
                                }
                                v158 = v163;
                                strcmp_rc = strcmp((char *)(v158 + v164), (char *)str);
                                v159 = v158;
                            }
                        }
                        // 0xd248
                        v157 = v153;
                        if (v159 == v162) {
                            // 0xd254
                            str2 = (char *)str;
                            strcpy((char *)(v162 + v164), str2);
                            v157 = v153 + 1 + (char)strlen(str2);
                        }
                        // 0xd298
                        *(int32_t *)(4 * (int32_t)*v160 + v103) = v159;
                        v155 = g41;
                        v156 = v157;
                    }
                }
                // 0xd2c0
                v165 = v154 + 1;
                v118 = v156;
            }
        }
        // 0xd2d8
        g83 = g94;
        g85 = g95;
        g86 = g96;
        g87 = g97;
        g88 = g98;
        g89 = g99;
        g90 = g100;
        g91 = g101;
        g92 = g102;
        g93 = g103;
        g82 = 0x66695a54;
        *(char *)&g83 = 50;
        int32_t v167 = eitol(v147); // 0xd330
        convert(v167, &g88);
        int32_t v168 = eitol(v147); // 0xd348
        convert(v168, &g89);
        int32_t v169 = eitol(v134); // 0xd364
        convert(v169, &g90);
        int32_t v170 = eitol(v136); // 0xd380
        convert(v170, &g91);
        int32_t v171 = eitol(v147); // 0xd398
        convert(v171, &g92);
        nmemb2 = v118;
        int32_t v172 = eitol(nmemb2); // 0xd3b4
        convert(v172, &g93);
        fwrite(&g82, 4, 1, stream);
        fwrite(&g83, 1, 1, stream);
        fwrite(&g84, 15, 1, stream);
        fwrite(&g88, 4, 1, stream);
        fwrite(&g89, 4, 1, stream);
        fwrite(&g90, 4, 1, stream);
        fwrite(&g91, 4, 1, stream);
        fwrite(&g92, 4, 1, stream);
        fwrite(&g93, 4, 1, stream);
        int32_t v173 = v137; // 0xd508
        if (v137 < v73) {
            while (true) {
                uint64_t v174 = *(int64_t *)(8 * v173 + v2 - 0x25a8);
                if (v78 == 1) {
                    // 0xd49c
                    puttzcode((int32_t)(v174 / 0x100000000), v76);
                } else {
                    // 0xd4cc
                    puttzcode64((int32_t)(v174 / 0x100000000), (int32_t)v174, v76);
                }
                int32_t v175 = v173 + 1; // 0xd4f8
                v173 = v175;
                v68 = v137;
                if (v175 >= v73) {
                    goto lab_0xd518;
                }
            }
        }
        goto lab_0xd75c;
    }
  lab_0xdb24:
    // 0xdb24
    fprintf(stream, "\n%s\n", str3);
    if (ferror(stream) == 0) {
        // 0xdb58
        if (fclose(stream) == 0) {
            // 0xdba8
            return 0;
        }
    }
    // 0xdb6c
    fprintf(g21, "%s: Error writing %s\n", g39, g81);
    exit(1);
    // UNREACHABLE
}

// Address range: 0xdbd0 - 0xdda4
int32_t doabbr(int32_t str3, uint32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    char * str = (char *)a2; // 0xdbf4
    char * found_char_pos = strchr(str, 47); // 0xdbf4
    int32_t dest_str; // 0xdbd0
    if (found_char_pos == NULL) {
        char * str2 = (char *)str3;
        if (a3 == 0) {
            // 0xdc10
            dest_str = (int32_t)strcpy(str2, str);
        } else {
            // 0xdc20
            dest_str = sprintf(str2, str);
        }
    } else {
        int32_t v1 = (int32_t)found_char_pos; // 0xdbf4
        if (a4 == 0) {
            int32_t dest_str2 = v1; // 0xdc5c
            if (v1 != a2 && v1 >= a2) {
                // 0xdc60
                dest_str2 = (int32_t)strncpy((char *)str3, str, v1 - a2);
            }
            // 0xdc7c
            *(char *)(str3 - a2 + v1) = 0;
            dest_str = dest_str2;
        } else {
            // 0xdc40
            dest_str = (int32_t)strcpy((char *)str3, (char *)(v1 + 1));
        }
    }
    // 0xdc98
    if (a5 == 0) {
        // 0xdd9c
        return dest_str;
    }
    char * c2 = (char *)str3;
    char c = *c2; // 0xdcf8
    int32_t v2 = str3; // 0xdd00
    char * v3 = c2; // 0xdd00
    if (c != 0) {
        if (strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", (int32_t)c) == NULL) {
            // 0xdcd0
            if (strchr("abcdefghijklmnopqrstuvwxyz", (int32_t)*c2) == NULL) {
                // break -> 0xdd04
                break;
            }
        }
        // 0xdcf4
        v2++;
        char * v4 = (char *)v2; // 0xdcf8
        char c3 = *v4; // 0xdcf8
        char * c4 = v4; // 0xdd00
        v3 = v4;
        while (c3 != 0) {
            // 0xdcb0
            if (strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", (int32_t)c3) == NULL) {
                // 0xdcd0
                v3 = c4;
                if (strchr("abcdefghijklmnopqrstuvwxyz", (int32_t)*c4) == NULL) {
                    // break -> 0xdd04
                    break;
                }
            }
            // 0xdcf4
            v2++;
            v4 = (char *)v2;
            c3 = *v4;
            c4 = v4;
            v3 = v4;
        }
    }
    int32_t len = strlen(c2); // 0xdd08
    if (len >= 1) {
        // 0xdd1c
        if (*v3 == 0) {
            // 0xdd9c
            return len;
        }
    }
    int32_t v5 = len + str3;
    *(char *)(v5 + 2) = 0;
    *(char *)(v5 + 1) = 62;
    if (len > 0) {
        int32_t v6 = len - 1; // 0xdd70
        *(char *)(len + str3) = *(char *)(v6 + str3);
        while (v6 > 0) {
            int32_t v7 = v6;
            v6 = v7 - 1;
            *(char *)(v7 + str3) = *(char *)(v6 + str3);
        }
    }
    // 0xdd90
    *c2 = 60;
    // 0xdd9c
    return len;
}

// Address range: 0xdda4 - 0xde10
int32_t updateminmax(int32_t result) {
    // 0xdda4
    if (g35 > result) {
        // 0xddcc
        g35 = result;
    }
    // 0xdddc
    if (g32 < result) {
        // 0xddf4
        g32 = result;
    }
    // 0xde04
    return result;
}

// Address range: 0xde10 - 0xdfc0
int32_t stringoffset(int32_t a1, int32_t a2) {
    char * str = (char *)a1; // 0xde2c
    *str = 0;
    int32_t v1 = a2; // 0xde38
    if (a2 < 0) {
        // 0xde3c
        *(int16_t *)a1 = 45;
        v1 = -a2;
    }
    int32_t v2 = v1;
    int32_t v3 = (v2 + (int32_t)((int64_t)v2 * (int64_t)((int32_t)"oc" & 0xffff | -0x77780000) / 0x100000000) >> 5) - (v2 >> 31); // 0xde78
    uint32_t v4 = (v3 + (int32_t)((int64_t)v3 * (int64_t)((int32_t)"oc" & 0xffff | -0x77780000) / 0x100000000) >> 5) - (v3 >> 31); // 0xded0
    if (v4 >= 24) {
        // 0xdf18
        *str = 0;
        // 0xdfb4
        return -1;
    }
    int32_t v5 = -60 * v3 + v2; // 0xde8c
    int32_t v6 = -60 * v4 + v3; // 0xdee4
    sprintf(strchr(str, 0), "%d", v4);
    if ((v6 || v5) == 0) {
        // 0xdfb4
        return 0;
    }
    // 0xdf60
    sprintf(strchr(str, 0), ":%02d", v6);
    if (v5 != 0) {
        // 0xdf8c
        sprintf(strchr(str, 0), ":%02d", v5);
    }
    // 0xdfb4
    return 0;
}

// Address range: 0xdfc0 - 0xe278
int32_t stringrule(int32_t str, int32_t a2, int32_t a3, int32_t a4) {
    char * found_char_pos = strchr((char *)str, 0); // 0xdfe4
    int32_t result = -1; // 0xdfc0
    int32_t v1; // 0xdfc0
    int32_t v2; // 0xdfc0
    switch (*(int32_t *)(a2 + 36)) {
        case 0: {
            int32_t v3 = *(int32_t *)(a2 + 40); // 0xe000
            uint32_t v4 = *(int32_t *)(a2 + 32);
            if (v3 == 29 == v4 == 1) {
                // 0xe26c
                return -1;
            }
            int32_t v5 = 0; // 0xe050
            int32_t v6 = 0; // 0xe050
            if (v4 > 0) {
                int32_t v7 = *(int32_t *)(4 * v5 + (int32_t)&g9); // 0xe03c
                int32_t v8 = v5 + 1; // 0xe040
                v5 = v8;
                int32_t v9 = v7; // 0xe050
                v6 = v7;
                while (v4 > v8) {
                    int32_t v10 = *(int32_t *)(4 * v5 + (int32_t)&g9); // 0xe038
                    v7 = v10 + v9;
                    v8 = v5 + 1;
                    v5 = v8;
                    v9 = v7;
                    v6 = v7;
                }
            }
            // 0xe054
            sprintf(found_char_pos, "J%d", v6 + v3);
            goto lab_0xe1a4;
        }
        case 1: {
            int32_t v11 = *(int32_t *)(a2 + 40); // 0xe08c
            int32_t v12 = (v11 + (int32_t)(-0x6db6db6d * (int64_t)v11 / 0x100000000) >> 2) - (v11 >> 31); // 0xe0a8
            if (7 * v12 + 1 != v11) {
                // 0xe26c
                return -1;
            }
            // 0xe088
            v1 = *(int32_t *)(a2 + 32);
            v2 = v12 + 1;
            goto lab_0xe174;
        }
        case 2: {
            int32_t v13 = *(int32_t *)(a2 + 40); // 0xe0f0
            int32_t v14 = *(int32_t *)(a2 + 32); // 0xe0f8
            v1 = v14;
            v2 = 5;
            if (v13 != *(int32_t *)(4 * v14 + (int32_t)&g9 + 48)) {
                int32_t v15 = (v13 + (int32_t)(-0x6db6db6d * (int64_t)v13 / 0x100000000) >> 2) - (v13 >> 31) + 1; // 0xe140
                v1 = v14;
                v2 = v15;
                if (7 * v15 - 1 != v13) {
                    // 0xe26c
                    return -1;
                }
            }
            goto lab_0xe174;
        }
        default: {
            return result;
        }
    }
  lab_0xe1a4:;
    int32_t v16 = (*(int32_t *)(a2 + 56) == 0 ? 0 : a4) + *(int32_t *)(a2 + 48);
    int32_t v17 = v16; // 0xe1d0
    if (*(int32_t *)(a2 + 52) != 0) {
        // 0xe1d4
        v17 = (*(int32_t *)(a2 + 60) == 0 ? a3 : 0) + v16;
    }
    // 0xe1ec
    if (v17 < 0) {
        // 0xe1f4
        *found_char_pos = 0;
        // 0xe26c
        return -1;
    }
    if (v17 == 0x1c20) {
        // 0xe26c
        return 0;
    }
    // 0xe214
    *(int16_t *)(strlen(found_char_pos) + (int32_t)found_char_pos) = 47;
    char * found_char_pos2 = strchr(found_char_pos, 0); // 0xe240
    result = -1;
    if (stringoffset((int32_t)found_char_pos2, v17) == 0) {
        // 0xe26c
        return 0;
    }
    // 0xe26c
    return result;
  lab_0xe174:
    // 0xe174
    sprintf(found_char_pos, "M%d.%d.%d", v1 + 1, v2, *(int32_t *)(a2 + 44));
    goto lab_0xe1a4;
}

// Address range: 0xe278 - 0xe5dc
int32_t stringzone(int32_t result, int32_t a2, int32_t a3) {
    char * str = (char *)result; // 0xe298
    *str = 0;
    int32_t v1 = a2 - 128 + 128 * a3; // 0xe2b0
    uint32_t v2 = *(int32_t *)(v1 + 32); // 0xe344
    int32_t v3 = 0; // 0xe34c
    int32_t v4 = 0; // 0xe34c
    if (v2 > 0) {
        int32_t v5 = 0; // 0xe340
        int32_t v6 = 0;
        int32_t v7 = 0;
        int32_t v8 = 80 * v5 + *(int32_t *)(v1 + 28); // 0xe2dc
        int32_t v9 = v6; // 0xe2e8
        int32_t v10 = v7; // 0xe2e8
        if (*(int32_t *)(v8 + 28) == 0) {
            // 0xe2ec
            v9 = v6;
            v10 = v7;
            if (*(int32_t *)(v8 + 16) == 0x7fffffff) {
                // 0xe2fc
                v9 = v6;
                v10 = v7;
                if (*(int32_t *)(v8 + 20) == 0) {
                    // 0xe30c
                    if (*(int32_t *)(v8 + 60) == 0) {
                        // 0xe318
                        v9 = v8;
                        v10 = v7;
                        if (v6 != 0) {
                            // 0xe5d4
                            return result;
                        }
                    } else {
                        // 0xe32c
                        v9 = v6;
                        v10 = v8;
                        if (v7 != 0) {
                            // 0xe5d4
                            return result;
                        }
                    }
                }
            }
        }
        int32_t v11 = v10;
        int32_t v12 = v9;
        v5++;
        v3 = v12;
        v4 = v11;
        while (v2 > v5) {
            // 0xe2c4
            v6 = v12;
            v7 = v11;
            v8 = 80 * v5 + *(int32_t *)(v1 + 28);
            v9 = v6;
            v10 = v7;
            if (*(int32_t *)(v8 + 28) == 0) {
                // 0xe2ec
                v9 = v6;
                v10 = v7;
                if (*(int32_t *)(v8 + 16) == 0x7fffffff) {
                    // 0xe2fc
                    v9 = v6;
                    v10 = v7;
                    if (*(int32_t *)(v8 + 20) == 0) {
                        // 0xe30c
                        if (*(int32_t *)(v8 + 60) == 0) {
                            // 0xe318
                            v9 = v8;
                            v10 = v7;
                            if (v6 != 0) {
                                // 0xe5d4
                                return result;
                            }
                        } else {
                            // 0xe32c
                            v9 = v6;
                            v10 = v8;
                            if (v7 != 0) {
                                // 0xe5d4
                                return result;
                            }
                        }
                    }
                }
            }
            // 0xe340
            v11 = v10;
            v12 = v9;
            v5++;
            v3 = v12;
            v4 = v11;
        }
    }
    // 0xe350
    int32_t v13; // 0xe278
    int32_t v14; // 0xe278
    int32_t v15; // 0xe278
    int32_t v16; // 0xe278
    int32_t v17; // 0xe278
    if ((v4 || v3) == 0) {
        // 0xe3c4
        v15 = v3;
        if (v2 > 0) {
            // 0xe368
            v17 = 0;
            v14 = v3;
            while (true) {
              lab_0xe368:;
                int32_t v18 = v14;
                int32_t v19 = 80 * v17 + *(int32_t *)(v1 + 28); // 0xe380
                if (v18 == 0) {
                    // 0xe3bc
                    v13 = v19;
                    goto lab_0xe3c0;
                } else {
                    int32_t v20 = *(int32_t *)(v19 + 16); // 0xe38c
                    int32_t v21 = *(int32_t *)(v18 + 16); // 0xe390
                    if (v20 > v21) {
                        // 0xe3bc
                        v13 = v19;
                        goto lab_0xe3c0;
                    } else {
                        // 0xe39c
                        v13 = v18;
                        if (v20 == v21) {
                            // 0xe3ac
                            v13 = v18;
                            if (*(int32_t *)(v19 + 32) > *(int32_t *)(v18 + 32)) {
                                // 0xe3bc
                                v13 = v19;
                                goto lab_0xe3c0;
                            } else {
                                goto lab_0xe3c0;
                            }
                        } else {
                            goto lab_0xe3c0;
                        }
                    }
                }
            }
        }
      lab_0xe3d0:
        // 0xe3d0
        if (v15 == 0) {
            goto lab_0xe40c;
        } else {
            // 0xe3d8
            if (*(int32_t *)(v15 + 60) != 0) {
                // 0xe5d4
                return result;
            }
            // 0xe3f0
            v16 = v15;
            if (*(int32_t *)(v15 + 16) == 2037) {
                // 0xe5d4
                return result;
            }
            goto lab_0xe424;
        }
    } else {
        // 0xe404
        v16 = v3;
        if (v3 == 0) {
            goto lab_0xe40c;
        } else {
            goto lab_0xe424;
        }
    }
  lab_0xe3c0:;
    int32_t v22 = v17 + 1; // 0xe3c0
    v17 = v22;
    v14 = v13;
    v15 = v13;
    if (v2 <= v22) {
        // break -> 0xe3d0
        goto lab_0xe3d0;
    }
    goto lab_0xe368;
  lab_0xe40c:;
    int32_t v23 = 0; // 0xe414
    int32_t v24 = &g13; // 0xe414
    if (v2 != 0) {
        // 0xe5d4
        return result;
    }
    goto lab_0xe434;
  lab_0xe424:
    // 0xe424
    v23 = v16;
    v24 = *(int32_t *)(v16 + 64);
    goto lab_0xe434;
  lab_0xe434:;
    int32_t * v25 = (int32_t *)(v1 + 20); // 0xe438
    doabbr(result, *v25, v24, 0, 1);
    char * found_char_pos = strchr(str, 0); // 0xe460
    int32_t * v26 = (int32_t *)(v1 + 12); // 0xe468
    int32_t result2 = stringoffset((int32_t)found_char_pos, -*v26); // 0xe478
    if (result2 != 0) {
        // 0xe488
        *str = 0;
        // 0xe5d4
        return result2;
    }
    // 0xe498
    if (v4 == 0) {
        // 0xe5d4
        return 0;
    }
    char * found_char_pos2 = strchr(str, 0); // 0xe4ac
    doabbr((int32_t)found_char_pos2, *v25, *(int32_t *)(v4 + 64), 1, 1);
    int32_t * v27 = (int32_t *)(v4 + 60); // 0xe4d8
    if (*v27 != 3600) {
        char * found_char_pos3 = strchr(str, 0); // 0xe4ec
        int32_t result3 = stringoffset((int32_t)found_char_pos3, -((*v26 + *v27))); // 0xe50c
        if (result3 != 0) {
            // 0xe51c
            *str = 0;
            // 0xe5d4
            return result3;
        }
    }
    // 0xe52c
    *(int16_t *)(strlen(str) + result) = 44;
    int32_t result4 = stringrule(result, v4, *v27, *v26); // 0xe560
    if (result4 != 0) {
        // 0xe570
        *str = 0;
        // 0xe5d4
        return result4;
    }
    // 0xe580
    *(int16_t *)(strlen(str) + result) = 44;
    int32_t v28 = stringrule(result, v23, *v27, *v26); // 0xe5b4
    int32_t result5 = 0; // 0xe5c0
    if (v28 != 0) {
        // 0xe5c4
        *str = 0;
        result5 = v28;
    }
    // 0xe5d4
    return result5;
}

// Address range: 0xe5dc - 0xf148
int32_t outzone(int32_t a1, uint32_t a2) {
    int32_t v1 = g29 + 2 + g28; // 0xe60c
    int32_t v2 = v1 + 1; // 0xe618
    int32_t v3 = memcheck(imalloc(v2)); // 0xe62c
    int32_t v4 = memcheck(imalloc(v2)); // 0xe648
    int32_t v5 = memcheck(imalloc(2 * v1 + 46)); // 0xe664
    g40 = 0;
    g41 = 0;
    g22 = 0;
    g32 = 1970;
    g35 = 1970;
    int32_t v6 = *(int32_t *)((int32_t)&g107 & 0xffff | (int32_t)&g1); // 0xe6f4
    if (v6 != 0) {
        // 0xe700
        updateminmax(g25);
        updateminmax(g26);
    }
    for (int32_t i = 0; i < a2; i++) {
        int32_t v7 = 128 * i + a1; // 0xe740
        if (a2 - 1 > i) {
            // 0xe758
            updateminmax(*(int32_t *)(v7 + 52));
        }
        int32_t * v8 = (int32_t *)(v7 + 32); // 0xe7bc
        if (*v8 > 0) {
            for (int32_t j = 0; j < *v8; j++) {
                int32_t v9 = *(int32_t *)(v7 + 28) + 80 * j; // 0xe784
                if (*(int32_t *)(v9 + 24) != 0) {
                    // 0xe794
                    updateminmax(*(int32_t *)(v9 + 12));
                }
                // 0xe7a0
                if (*(int32_t *)(v9 + 28) != 0) {
                    // 0xe7ac
                    updateminmax(*(int32_t *)(v9 + 16));
                }
            }
        }
    }
    char * v10 = (char *)v5; // 0xe668
    stringzone(v5, a1, a2);
    int32_t v11; // 0xe5dc
    if (g36 == 0) {
        goto lab_0xe888;
    } else {
        // 0xe808
        if (*v10 == 0) {
            int32_t v12 = memcheck(icpyalloc("no POSIX environment variable for zone")); // 0xe82c
            int32_t v13 = icatalloc(v12, (int32_t)&g14); // 0xe840
            int32_t v14 = memcheck(v13); // 0xe84c
            int32_t v15 = memcheck(icatalloc(v14, *(int32_t *)(a1 + 8))); // 0xe870
            warning((char *)v15);
            ifree(v15);
            goto lab_0xe888;
        } else {
            // 0xe930
            v11 = g35;
            goto lab_0xe930_2;
        }
    }
  lab_0xed7c:;
    // 0xed7c
    int32_t v16; // 0xe5dc
    int32_t v17 = v16;
    int64_t v18; // 0xe5dc
    int64_t v19 = v18;
    int32_t v20; // 0xe5dc
    int32_t v21 = v20 + 1; // 0xed7c
    int32_t v22 = v21; // 0xed88
    int32_t v23 = v17; // 0xed88
    int64_t v24 = v19; // 0xed88
    int32_t * v25; // 0xea5c
    if (*v25 <= v21) {
        // break -> 0xed8c
        goto lab_0xed8c;
    }
    goto lab_0xec90;
  lab_0xed24:;
    uint64_t v41 = *(int64_t *)&g30; // 0xed2c
    int32_t v27; // 0xe5dc
    int64_t v26; // 0xe5dc
    int32_t v38; // 0xed08
    int32_t v39; // 0xed08
    if (v38 == (int32_t)v41) {
        v18 = v26;
        v16 = v27;
        if (v39 == (int32_t)(v41 / 0x100000000)) {
            goto lab_0xed7c;
        } else {
            goto lab_0xed40;
        }
    } else {
        goto lab_0xed40;
    }
  lab_0xed40:;
    // 0xed40
    int32_t v36; // 0xe5dc
    uint32_t v42 = tadd((int64_t)v39, v38, -v36); // 0xed50
    if (v27 < 0) {
        // 0xed74
        v18 = v42;
        v16 = v20;
        goto lab_0xed7c;
    } else {
        uint64_t v43 = 0x100000000 * v26 >> 32; // 0xed64
        v18 = v26;
        v16 = v27;
        if (((v38 - (int32_t)v43) % 2 != 0) < (v42 < (int32_t)(v43 / 0x100000000))) {
            // 0xed74
            v18 = v42;
            v16 = v20;
            goto lab_0xed7c;
        } else {
            goto lab_0xed7c;
        }
    }
  lab_0xeee4:;
    // 0xeee4
    int32_t v44; // 0xedb0
    int32_t * v30; // 0xea34
    int32_t * v31; // 0xea38
    eats(*v30, *v31, *(int32_t *)v44, *(int32_t *)(v44 + 4));
    int32_t * v45; // 0xede0
    int32_t * v46; // 0xe5dc
    doabbr(v4, *v46, *(int32_t *)(v44 + 64), (int32_t)(*v45 != 0), 0);
    int32_t * v47; // 0xea2c
    int32_t v48 = oadd(*v47, *v45); // 0xef3c
    int32_t v49 = *v45; // 0xef44
    int32_t v50 = *(int32_t *)(v44 + 52); // 0xef5c
    int32_t v51 = *(int32_t *)(v44 + 56); // 0xef60
    int64_t v52; // 0xe5dc
    int32_t v53; // 0xe5dc
    addtt(v52 >> 63, v53, addtype(v48, v4, (int32_t)(v49 != 0), v50, v51));
    int64_t v54; // 0xe5dc
    int64_t v55 = v54; // 0xef88
    int32_t v56; // 0xede0
    int32_t v57 = v56; // 0xef88
    int32_t v58; // 0xe5dc
    int32_t v59 = v58; // 0xef88
    int32_t v60; // 0xe5dc
    int32_t v61 = v60; // 0xef88
    goto lab_0xec1c;
  lab_0xec0c:;
    // 0xec0c
    int32_t v85; // 0xe5dc
    int32_t v86 = v85 + 1; // 0xec0c
    v85 = v86;
    if (*v25 <= v86) {
        // break -> 0xec1c
        goto lab_0xec1c_2;
    }
    goto lab_0xeb74;
  lab_0xe9dc:;
    // 0xe9dc
    int32_t v90; // 0xe5dc
    int32_t v91 = v90;
    int64_t v92; // 0xe5dc
    int64_t v93; // 0xe5dc
    int64_t v94; // 0xe5dc
    int64_t v95; // 0xe5dc
    int32_t v96; // 0xe5dc
    int32_t v97; // 0xe5dc
    int32_t v98; // 0xe5dc
    int32_t v99; // 0xe5dc
    int32_t v68; // 0xe5dc
    int32_t v67; // 0xe9e4
    int32_t v100; // 0xe9a0
    if (v67 <= v68) {
        goto lab_0xea2c;
    } else {
        uint64_t v101 = *(int64_t *)(v100 + 120); // 0xea0c
        uint64_t v102 = *(int64_t *)&g33; // 0xea18
        v94 = v95;
        v92 = v93;
        v96 = v97;
        v98 = v99;
        if (((v102 ^ v101) % 2 != 0) < ((int32_t)(v102 / 0x100000000) < (int32_t)(v101 / 0x100000000))) {
            goto lab_0xea2c;
        } else {
            goto lab_0xf0f8;
        }
    }
  lab_0xea2c:
    // 0xea2c
    v47 = (int32_t *)(v100 + 12);
    int32_t v33 = *v47; // 0xea2c
    v30 = (int32_t *)v100;
    v31 = (int32_t *)(v100 + 4);
    eat(*v30, *v31);
    char * str3; // 0xe630
    *str3 = 0;
    v25 = (int32_t *)(v100 + 32);
    int64_t v103; // 0xe5dc
    int32_t v104; // 0xe5dc
    if (*v25 == 0) {
        int32_t v105 = *(int32_t *)(v100 + 24); // 0xea68
        int32_t v106 = v105 != 0;
        doabbr(v3, *(int32_t *)(v100 + 20), 0, v106, 0);
        int32_t v107 = addtype(oadd(*v47, v105), v3, v106, v97, v99); // 0xeae8
        if (v91 == 0) {
            // 0xeb14
            v104 = 0;
            v103 = v95;
            if (v105 != 0) {
                int64_t v108 = *(int64_t *)&g33; // 0xeb28
                addtt(v108 >> 32, (int32_t)v108, v107);
                v104 = v105;
                v103 = v95;
            }
        } else {
            // 0xeafc
            addtt(0x100000000 * v93 >> 63, (int32_t)v93, v107);
            v104 = v105;
            v103 = v95;
        }
    } else {
        int32_t v109 = *v47; // 0xea54
        int32_t v110 = g35; // 0xeb48
        int64_t v111 = v95; // 0xefa0
        int32_t v112 = 0; // 0xefa0
        int32_t v113 = v91; // 0xefa0
        int32_t v114 = v109; // 0xefa0
        if (v110 <= g32) {
            int32_t * v115 = (int32_t *)(v100 + 56);
            int32_t * v29 = (int32_t *)(v100 + 28);
            int64_t * v70 = (int64_t *)(v100 + 120);
            int32_t * v73 = (int32_t *)(v100 + 96);
            int32_t v74 = -v33;
            int32_t * v76 = (int32_t *)(v100 + 92);
            uint64_t v83 = 0x100000000 * v93 >> 32;
            int32_t v81 = v83;
            uint32_t v82 = (int32_t)(v83 / 0x100000000);
            v46 = (int32_t *)(v100 + 20);
            int32_t v116 = v110; // 0xef8c
            int32_t v117 = v109; // 0xe5dc
            int32_t v118 = v91; // 0xe5dc
            int32_t v119 = 0; // 0xe5dc
            int64_t v120 = v95; // 0xe5dc
            while (true) {
                int64_t v121 = v120;
                int32_t v122 = v119;
                int32_t v123 = v118;
                int32_t v124 = v117;
                int32_t v89 = v116;
                if (v67 > v68) {
                    // 0xeb5c
                    v111 = v121;
                    v112 = v122;
                    v113 = v123;
                    v114 = v124;
                    if (*v115 < v89) {
                        // break -> 0xefa4
                        break;
                    }
                }
                // 0xeb6c
                v85 = 0;
                if (*v25 > 0) {
                    while (true) {
                      lab_0xeb74:;
                        int32_t v87 = *v29 + 80 * v85; // 0xeb8c
                        int32_t * v88 = (int32_t *)v87; // 0xeb98
                        eats(*v30, *v31, *v88, *(int32_t *)(v87 + 4));
                        if (*(int32_t *)(v87 + 12) > v89) {
                            // 0xebe4
                            *(int32_t *)(v87 + 68) = 0;
                            goto lab_0xec0c;
                        } else {
                            // 0xebb0
                            if (*(int32_t *)(v87 + 16) < v89) {
                                // 0xebe4
                                *(int32_t *)(v87 + 68) = 0;
                                goto lab_0xec0c;
                            } else {
                                // 0xebbc
                                if (yearistype(v89, *(int32_t *)(v87 + 20)) == 0) {
                                    // 0xebe4
                                    *(int32_t *)(v87 + 68) = 0;
                                    goto lab_0xec0c;
                                } else {
                                    // 0xebf4
                                    *(int32_t *)(v87 + 68) = 1;
                                    *(int32_t *)(v87 + 72) = rpytime(v88, v89);
                                    *(int32_t *)(v87 + 76) = v89;
                                    goto lab_0xec0c;
                                }
                            }
                        }
                    }
                }
              lab_0xec1c_2:
                // 0xec1c
                v55 = v121;
                v57 = v122;
                v59 = v123;
                v61 = v124;
                int32_t v62; // 0xe5dc
                int32_t v35; // 0xe5dc
                while (true) {
                  lab_0xec1c:
                    // 0xec1c
                    v62 = v59;
                    int64_t v63 = v55; // 0xe5dc
                    int32_t v64 = v57; // 0xe5dc
                    int32_t v65 = v61; // 0xee3c
                    while (true) {
                        // 0xec1c
                        v60 = v65;
                        v35 = v64;
                        int64_t v66 = v63; // 0xec30
                        if (v67 > v68) {
                            int64_t v69 = *v70; // 0xec34
                            int64_t v71 = v69 >> 32; // 0xec38
                            int64_t v72 = v71; // 0xec44
                            if (*v73 == 0) {
                                // 0xec48
                                v72 = tadd(v69 >> 63, (int32_t)v71, v74);
                            }
                            int64_t v75 = v72;
                            v66 = v75;
                            if (*v76 == 0) {
                                // 0xec6c
                                v66 = tadd(v75 >> 31, (int32_t)v75, -v35);
                            }
                        }
                        // 0xec84
                        v54 = v66;
                        v22 = 0;
                        v23 = -1;
                        v24 = 0;
                        if (*v25 <= 0) {
                            // break (via goto) -> 0xef8c
                            goto lab_0xef8c_3;
                        }
                        while (true) {
                          lab_0xec90:
                            // 0xec90
                            v26 = v24;
                            v27 = v23;
                            v20 = v22;
                            int32_t v28 = *v29 + 80 * v20; // 0xeca8
                            v18 = v26;
                            v16 = v27;
                            if (*(int32_t *)(v28 + 68) == 0) {
                                goto lab_0xed7c;
                            } else {
                                // 0xecbc
                                eats(*v30, *v31, *(int32_t *)v28, *(int32_t *)(v28 + 4));
                                int32_t v32 = *(int32_t *)(v28 + 56) == 0 ? v33 : 0;
                                int32_t v34 = v32; // 0xecf4
                                if (*(int32_t *)(v28 + 52) == 0) {
                                    // 0xecf8
                                    v34 = oadd(v32, v35);
                                }
                                // 0xed08
                                v36 = v34;
                                uint64_t v37 = *(int64_t *)(v28 + 72); // 0xed08
                                v38 = v37;
                                v39 = v37 / 0x100000000;
                                uint64_t v40 = *(int64_t *)&g33; // 0xed14
                                if (v38 == (int32_t)v40) {
                                    v18 = v26;
                                    v16 = v27;
                                    if (v39 == (int32_t)(v40 / 0x100000000)) {
                                        goto lab_0xed7c;
                                    } else {
                                        goto lab_0xed24;
                                    }
                                } else {
                                    goto lab_0xed24;
                                }
                            }
                        }
                      lab_0xed8c:
                        if (v17 < 0) {
                            // break (via goto) -> 0xef8c
                            goto lab_0xef8c_3;
                        }
                        // 0xed98
                        v44 = *v29 + 80 * v17;
                        *(int32_t *)(v44 + 68) = 0;
                        v52 = 0x100000000 * v19;
                        if (v67 > v68) {
                            uint64_t v77 = v52 >> 32; // 0xedc8
                            uint64_t v78 = 0x100000000 * v54 >> 32; // 0xedcc
                            if (((v77 ^ v78) % 2 != 0) >= ((int32_t)(v77 / 0x100000000) < (int32_t)(v78 / 0x100000000))) {
                                // break (via goto) -> 0xef8c
                                goto lab_0xef8c_3;
                            }
                        }
                        // 0xede0
                        v45 = (int32_t *)(v44 + 60);
                        v56 = *v45;
                        if (v62 == 0) {
                            // break -> 0xeee4
                            break;
                        }
                        uint64_t v79 = v52 >> 32;
                        uint32_t v80 = (int32_t)(v79 / 0x100000000);
                        if ((int32_t)v79 == v81 == v80 == v82) {
                            // break -> 0xeee4
                            break;
                        }
                        if (((v79 ^ v83) % 2 != 0) >= (v80 < v82)) {
                            int32_t v84 = v19;
                            v53 = v84;
                            v58 = v62;
                            if (*str3 == 0) {
                                // 0xee90
                                v53 = v84;
                                v58 = v62;
                                if (oadd(*v47, v56) == v60) {
                                    // 0xeeb0
                                    doabbr(v3, *v46, *(int32_t *)(v44 + 64), (int32_t)(*v45 != 0), 0);
                                    v53 = v84;
                                    v58 = v62;
                                    goto lab_0xeee4;
                                } else {
                                    goto lab_0xeee4;
                                }
                            } else {
                                goto lab_0xeee4;
                            }
                        }
                        // 0xee30
                        v65 = oadd(*v47, v56);
                        doabbr(v3, *v46, *(int32_t *)(v44 + 64), (int32_t)(*v45 != 0), 0);
                        v63 = v54;
                        v64 = v56;
                    }
                    // 0xeee4
                    v53 = v19;
                    v58 = 0;
                    goto lab_0xeee4;
                }
              lab_0xef8c_3:
                // 0xef8c
                v116 = v89 + 1;
                v117 = v60;
                v118 = v62;
                v119 = v35;
                v120 = v54;
                v111 = v54;
                v112 = v35;
                v113 = v62;
                v114 = v60;
                if (v116 > g32) {
                    // break -> 0xefa4
                    break;
                }
            }
        }
        int32_t v125 = v112;
        int64_t v126 = v111;
        v104 = v125;
        v103 = v126;
        if (v113 != 0) {
            int32_t v127 = v114;
            if (*str3 == 0) {
                int32_t * str2 = (int32_t *)(v100 + 20); // 0xefc0
                int32_t str = *str2; // 0xefc0
                if (str != 0) {
                    // 0xefcc
                    if (strchr((char *)str, 37) == NULL) {
                        // 0xefe8
                        if (strchr((char *)*str2, 47) == NULL) {
                            // 0xf004
                            strcpy(str3, (char *)*str2);
                        }
                    }
                }
            }
            // 0xf014
            eat(*v30, *v31);
            if (*str3 == 0) {
                // 0xf038
                error((int32_t)"can't determine time zone abbreviation to use just after until time");
                v104 = v125;
                v103 = v126;
            } else {
                int32_t v128 = *v47; // 0xf048
                addtt(0x100000000 * v93 >> 63, (int32_t)v93, addtype(v127, v3, (int32_t)(v128 != v127), v97, v99));
                v104 = v125;
                v103 = v126;
            }
        }
    }
    int64_t v129 = v103;
    v94 = v129;
    v92 = v93;
    v96 = v97;
    v98 = v99;
    if (v67 > v68) {
        int32_t v130 = *(int32_t *)(v100 + 92); // 0xf098
        int32_t v131 = *(int32_t *)(v100 + 96); // 0xf0a0
        int64_t v132 = *(int64_t *)(v100 + 120); // 0xf0a8
        int64_t v133 = v132 >> 32; // 0xf0ac
        int64_t v134 = v133; // 0xf0b8
        if (v130 == 0) {
            // 0xf0bc
            v134 = tadd(v132 >> 63, (int32_t)v133, -v104);
        }
        int64_t v135 = v134;
        v94 = v129;
        v92 = v135;
        v96 = v130;
        v98 = v131;
        if (v131 == 0) {
            // 0xf0e0
            v94 = v129;
            v92 = tadd(v135 >> 31, (int32_t)v135, -v33);
            v96 = v130;
            v98 = 0;
        }
    }
    goto lab_0xf0f8;
  lab_0xf0f8:;
    int32_t v136 = v68 + 1; // 0xf0fc
    int32_t v137 = v136; // 0xf110
    int32_t v138 = v98; // 0xf110
    int32_t v139 = v96; // 0xf110
    int64_t v140 = v92; // 0xf110
    int64_t v141 = v94; // 0xf110
    if (v136 >= a2) {
        // break -> 0xf114
        goto lab_0xf114;
    }
    goto lab_0xe98c;
  lab_0xe888:
    // 0xe888
    if (*v10 == 0) {
        int32_t v144 = g35; // 0xe8a0
        int32_t v145 = v144 < -0x7ffffe70 ? -0x80000000 : v144 - 400;
        g35 = v145;
        int32_t v146 = g32; // 0xe8ec
        if (v146 > 0x7ffffe6f) {
            // 0xe920
            g32 = 0x7fffffff;
            v11 = v145;
            goto lab_0xe930_2;
        } else {
            // 0xe900
            g32 = v146 + 400;
            // 0xe930
            v11 = g35;
            goto lab_0xe930_2;
        }
    } else {
        // 0xe930
        v11 = g35;
        goto lab_0xe930_2;
    }
  lab_0xe930_2:
    // 0xe930
    if (v11 >= 1901) {
        // 0xe948
        g35 = 1900;
    }
    // 0xe958
    if (g32 <= 2036) {
        // 0xe970
        g32 = 2037;
    }
    if (a2 > 0) {
        // 0xe98c
        str3 = (char *)v3;
        v67 = a2 - 1;
        v137 = 0;
        v138 = 0;
        v139 = 0;
        v140 = 0;
        v141 = 0;
        while (true) {
          lab_0xe98c:
            // 0xe98c
            v95 = v141;
            v93 = v140;
            v97 = v139;
            v99 = v138;
            v68 = v137;
            v100 = 128 * v68 + a1;
            if (v68 == 0) {
                // 0xe9d8
                v90 = 0;
                goto lab_0xe9dc;
            } else {
                uint64_t v142 = *(int64_t *)(v100 - 8); // 0xe9b4
                uint64_t v143 = *(int64_t *)&g33; // 0xe9c0
                v90 = 1;
                if (((v143 ^ v142) % 2 != 0) < ((int32_t)(v143 / 0x100000000) < (int32_t)(v142 / 0x100000000))) {
                    goto lab_0xe9dc;
                } else {
                    // 0xe9d8
                    v90 = 0;
                    goto lab_0xe9dc;
                }
            }
        }
    }
  lab_0xf114:
    // 0xf114
    writezone(*(int32_t *)(a1 + 8), v5);
    ifree(v3);
    ifree(v4);
    return ifree(v5);
}

// Address range: 0xf148 - 0xf378
int32_t addtt(int64_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a1;
    uint64_t v2 = *(int64_t *)&g33; // 0xf164
    uint32_t v3 = (int32_t)(v2 / 0x100000000); // 0xf164
    int32_t v4; // 0xf148
    char v5; // 0xf148
    if ((((int32_t)v2 - v1) % 2 != 0) < (v1 >> 31 > v3)) {
        int32_t v6 = g40;
        char v7 = a3;
        if (v6 == 1) {
            uint64_t v8 = *(int64_t *)&g48; // 0xf194
            v5 = v7;
            v4 = 1;
            if (((v8 ^ v2) % 2 != 0) < ((int32_t)(v8 / 0x100000000) < v3)) {
                goto lab_0xf1b0;
            } else {
                goto lab_0xf300;
            }
        } else {
            // 0xf2d8
            v5 = v7;
            v4 = v6;
            if (v6 >= 1200) {
                // 0xf2ec
                error((int32_t)"too many transitions?!");
                exit(1);
                // UNREACHABLE
            }
            goto lab_0xf300;
        }
    } else {
        goto lab_0xf1b0;
    }
  lab_0xf1b0:
    // 0xf1b0
    g49 = *(int32_t *)(4 * a3 + (int32_t)&g49);
    char v9 = *(char *)(a3 + (int32_t)&g50); // 0xf1dc
    *(char *)&g50 = v9;
    char v10 = *(char *)(a3 + (int32_t)&g52); // 0xf1fc
    *(char *)&g52 = v10;
    char v11 = *(char *)(a3 + (int32_t)&g53); // 0xf21c
    *(char *)&g53 = v11;
    unsigned char v12 = *(char *)(a3 + (int32_t)&g51); // 0xf23c
    if (v12 != 0) {
        // 0xf248
        strcpy((char *)&g54, (char *)((int32_t)v12 + (int32_t)&g54));
    }
    // 0xf2d8
    *(char *)&g51 = 0;
    g22 = strlen((char *)&g54) + 1;
    g41 = 1;
    g40 = 0;
    v5 = 0;
    v4 = 0;
    goto lab_0xf300;
  lab_0xf300:;
    int32_t v13 = 16 * v4; // 0xf314
    uint64_t v14 = 0x100000000 * a1 >> 32; // 0xf31c
    *(int32_t *)(v13 + (int32_t)&g48) = (int32_t)(v14 / 0x100000000);
    *(int32_t *)(v13 + (int32_t)&g48 + 4) = (int32_t)v14;
    int32_t result = 16 * g40; // 0xf344
    *(char *)(result + (int32_t)&g48 + 8) = v5;
    g40++;
    return result;
}

// Address range: 0xf378 - 0xf5f4
int32_t addtype(int32_t a1, int32_t str, uint32_t a3, uint32_t a4, uint32_t a5) {
    if (a3 >= 2) {
        // 0xf3ac
        error((int32_t)"internal error - addtype called with bad isdst");
        exit(1);
        // UNREACHABLE
    }
    if (a4 >= 2) {
        // 0xf3d8
        error((int32_t)"internal error - addtype called with bad ttisstd");
        exit(1);
        // UNREACHABLE
    }
    if (a5 >= 2) {
        // 0xf404
        error((int32_t)"internal error - addtype called with bad ttisgmt");
        exit(1);
        // UNREACHABLE
    }
    int32_t result2 = 0; // 0xf4dc
    if (g41 > 0) {
        int32_t v1 = 0;
        int32_t result; // 0xf378
        unsigned char v2; // 0xf45c
        int32_t strcmp_rc; // 0xf478
        unsigned char v3; // 0xf490
        unsigned char v4; // 0xf4ac
        unsigned char v5; // 0xf440
        if (*(int32_t *)(4 * v1 + (int32_t)&g49) == a1) {
            // 0xf438
            v5 = *(char *)(v1 + (int32_t)&g50);
            if ((int32_t)v5 == a3) {
                // 0xf454
                v2 = *(char *)(v1 + (int32_t)&g51);
                strcmp_rc = strcmp((char *)str, (char *)((int32_t)v2 + (int32_t)&g54));
                if (strcmp_rc == 0) {
                    // 0xf488
                    v3 = *(char *)(v1 + (int32_t)&g52);
                    if ((int32_t)v3 == a4) {
                        // 0xf4a4
                        v4 = *(char *)(v1 + (int32_t)&g53);
                        result = v1;
                        if ((int32_t)v4 == a5) {
                            // 0xf5e8
                            return result;
                        }
                    }
                }
            }
        }
        // 0xf4c8
        result2 = v1 + 1;
        while (result2 < g41) {
            // 0xf420
            v1 = result2;
            if (*(int32_t *)(4 * v1 + (int32_t)&g49) == a1) {
                // 0xf438
                v5 = *(char *)(v1 + (int32_t)&g50);
                if ((int32_t)v5 == a3) {
                    // 0xf454
                    v2 = *(char *)(v1 + (int32_t)&g51);
                    strcmp_rc = strcmp((char *)str, (char *)((int32_t)v2 + (int32_t)&g54));
                    if (strcmp_rc == 0) {
                        // 0xf488
                        v3 = *(char *)(v1 + (int32_t)&g52);
                        if ((int32_t)v3 == a4) {
                            // 0xf4a4
                            v4 = *(char *)(v1 + (int32_t)&g53);
                            result = v1;
                            if ((int32_t)v4 == a5) {
                                // 0xf5e8
                                return result;
                            }
                        }
                    }
                }
            }
            // 0xf4c8
            result2 = v1 + 1;
        }
        // 0xf4e0
        if (g41 >= 256) {
            // 0xf4f4
            error((int32_t)"too many local time types");
            exit(1);
            // UNREACHABLE
        }
    }
    // 0xf508
    *(int32_t *)(4 * result2 + (int32_t)&g49) = a1;
    *(char *)(result2 + (int32_t)&g50) = (char)a3;
    *(char *)(result2 + (int32_t)&g52) = (char)a4;
    *(char *)(result2 + (int32_t)&g53) = (char)a5;
    int32_t v6 = 0; // 0xf598
    if (g22 > 0) {
        int32_t v7 = 0;
        while (strcmp((char *)(v7 + (int32_t)&g54), (char *)str) != 0) {
            int32_t v8 = v7 + 1; // 0xf584
            v6 = v8;
            if (v8 >= g22) {
                goto lab_0xf59c;
            }
            v7 = v8;
        }
        // 0xf55c
        v6 = v7;
    }
  lab_0xf59c:
    // 0xf59c
    if (v6 == g22) {
        // 0xf5b0
        newabbr(str);
    }
    // 0xf5b8
    *(char *)(result2 + (int32_t)&g51) = (char)v6;
    g41++;
    // 0xf5e8
    return result2;
}

// Address range: 0xf5f4 - 0xf7f8
int32_t leapadd(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    uint32_t v1 = *(int32_t *)((int32_t)&g106 & 0xffff | (int32_t)&g1); // 0xf62c
    if (v1 + (a3 == 0 ? 1 : a5) >= 51) {
        // 0xf63c
        error((int32_t)"too many leap seconds");
        exit(1);
        // UNREACHABLE
    }
    uint32_t v2 = a1 >> 31;
    int32_t v3 = a1; // 0xf6cc
    int32_t v4 = 0; // 0xf6cc
    int32_t v5; // 0xf5f4
    int32_t v6; // 0xf5f4
    int32_t v7; // 0xf5f4
    int32_t v8; // 0xf5f4
    if (v1 > 0) {
        int32_t v9 = 0;
        int32_t v10 = 8 * v9;
        int32_t v11 = v10 + (int32_t)&g55;
        uint64_t v12 = *(int64_t *)v11; // 0xf668
        int32_t v13 = v12; // 0xf668
        int32_t v14 = v12 / 0x100000000; // 0xf668
        while (((v13 - a1) % 2 != 0) < (v2 > v14)) {
            int32_t v15 = v9 + 1; // 0xf6b8
            v3 = v14;
            v4 = v15;
            if (v15 >= v1) {
                goto lab_0xf6d0;
            }
            v9 = v15;
            v10 = 8 * v9;
            v11 = v10 + (int32_t)&g55;
            v12 = *(int64_t *)v11;
            v13 = v12;
            v14 = v12 / 0x100000000;
        }
        // 0xf67c
        v5 = v11;
        v6 = v10;
        v8 = v9;
        v7 = v14;
        if (v13 == a1 == v2 == v14) {
            // 0xf6a0
            error((int32_t)"repeated leap second moment");
            exit(1);
            // UNREACHABLE
        }
    } else {
      lab_0xf6d0:;
        int32_t v16 = 8 * v4; // 0xf758
        v5 = v16 + (int32_t)&g55;
        v6 = v16;
        v8 = v4;
        v7 = v3;
    }
    int32_t * v17 = (int32_t *)(4 * v8 + (int32_t)&g56);
    char v18 = a4;
    char * v19 = (char *)(v8 + (int32_t)&g57);
    int32_t v20 = a5;
    int32_t v21 = *(int32_t *)((int32_t)&g106 & (int32_t)&g108 | (int32_t)&g1); // 0xf6d8
    int32_t v22 = v21; // 0xf74c
    int32_t v23 = v7; // 0xf74c
    int32_t v24; // 0xf6e0
    uint64_t v25; // 0xf6f4
    int32_t v26; // 0xf6f4
    int32_t v27; // 0xf70c
    int32_t v28; // 0xf718
    char v29; // 0xf734
    int32_t v30; // 0xf744
    if (v21 > v8) {
        v24 = 8 * v22;
        v25 = *(int64_t *)(v24 + (int32_t)&g55 - 8);
        v26 = v25 / 0x100000000;
        *(int32_t *)(v24 + (int32_t)&g55) = v26;
        *(int32_t *)(v24 + (int32_t)&g55 + 4) = (int32_t)v25;
        v27 = 4 * v22;
        v28 = *(int32_t *)(v27 + (int32_t)&g56 - 4);
        *(int32_t *)(v27 + (int32_t)&g56) = v28;
        v29 = *(char *)(v22 + (int32_t)&g57 - 1);
        *(char *)(v22 + (int32_t)&g57) = v29;
        v30 = v22 - 1;
        v22 = v30;
        v23 = v26;
        while (v30 > v8) {
            // 0xf6e0
            v24 = 8 * v22;
            v25 = *(int64_t *)(v24 + (int32_t)&g55 - 8);
            v26 = v25 / 0x100000000;
            *(int32_t *)(v24 + (int32_t)&g55) = v26;
            *(int32_t *)(v24 + (int32_t)&g55 + 4) = (int32_t)v25;
            v27 = 4 * v22;
            v28 = *(int32_t *)(v27 + (int32_t)&g56 - 4);
            *(int32_t *)(v27 + (int32_t)&g56) = v28;
            v29 = *(char *)(v22 + (int32_t)&g57 - 1);
            *(char *)(v22 + (int32_t)&g57) = v29;
            v30 = v22 - 1;
            v22 = v30;
            v23 = v26;
        }
    }
    // 0xf750
    *(int32_t *)v5 = v2;
    *(int32_t *)(v6 + (int32_t)&g55 + 4) = a1;
    while (a3 != 0) {
        // 0xf7d8
        *v17 = 1;
        *v19 = v18;
        int32_t v31 = *(int32_t *)((int32_t)&g106 & 0xffff | (int32_t)&g1); // 0xf7b8
        *(int32_t *)((int32_t)&g106 & 0xffff | (int32_t)&g1) = v31 + 1;
        int32_t v32 = v20 - 1; // 0xf7dc
        int32_t result = v23; // 0xf7ec
        if (v32 == 0) {
            // 0xf7f0
            return result;
        }
        v20 = v32;
        v21 = *(int32_t *)((int32_t)&g106 & (int32_t)&g108 | (int32_t)&g1);
        v22 = v21;
        if (v21 > v8) {
            v24 = 8 * v22;
            v25 = *(int64_t *)(v24 + (int32_t)&g55 - 8);
            v26 = v25 / 0x100000000;
            *(int32_t *)(v24 + (int32_t)&g55) = v26;
            *(int32_t *)(v24 + (int32_t)&g55 + 4) = (int32_t)v25;
            v27 = 4 * v22;
            v28 = *(int32_t *)(v27 + (int32_t)&g56 - 4);
            *(int32_t *)(v27 + (int32_t)&g56) = v28;
            v29 = *(char *)(v22 + (int32_t)&g57 - 1);
            *(char *)(v22 + (int32_t)&g57) = v29;
            v30 = v22 - 1;
            v22 = v30;
            v23 = v26;
            while (v30 > v8) {
                // 0xf6e0
                v24 = 8 * v22;
                v25 = *(int64_t *)(v24 + (int32_t)&g55 - 8);
                v26 = v25 / 0x100000000;
                *(int32_t *)(v24 + (int32_t)&g55) = v26;
                *(int32_t *)(v24 + (int32_t)&g55 + 4) = (int32_t)v25;
                v27 = 4 * v22;
                v28 = *(int32_t *)(v27 + (int32_t)&g56 - 4);
                *(int32_t *)(v27 + (int32_t)&g56) = v28;
                v29 = *(char *)(v22 + (int32_t)&g57 - 1);
                *(char *)(v22 + (int32_t)&g57) = v29;
                v30 = v22 - 1;
                v22 = v30;
                v23 = v26;
            }
        }
        // 0xf750
        *(int32_t *)v5 = v2;
        *(int32_t *)(v6 + (int32_t)&g55 + 4) = a1;
    }
    int32_t result2 = eitol(-v20); // 0xf780
    *v17 = result2;
    *v19 = v18;
    int32_t v33 = *(int32_t *)((int32_t)&g106 & 0xffff | (int32_t)&g1); // 0xf7b8
    *(int32_t *)((int32_t)&g106 & 0xffff | (int32_t)&g1) = v33 + 1;
    // 0xf7f0
    return result2;
}

// Address range: 0xf7f8 - 0xf888
int32_t adjleap(void) {
    uint32_t v1 = *(int32_t *)((int32_t)&g106 & 0xffff | (int32_t)&g1); // 0xf878
    int32_t v2 = 0; // 0xf880
    if (v1 <= 0) {
        // 0xf884
        int32_t result; // 0xf7f8
        return result;
    }
    int32_t v3 = 0; // 0xf880
    int32_t v4 = 8 * v2; // 0xf814
    int32_t v5 = v4 + (int32_t)&g55; // 0xf818
    int64_t v6 = *(int64_t *)v5; // 0xf81c
    int32_t v7 = v6; // 0xf81c
    int32_t result2 = tadd(v6 >> 32, v7, v3); // 0xf82c
    *(int32_t *)v5 = result2;
    *(int32_t *)(v4 + (int32_t)&g55 + 4) = v7;
    int32_t * v8 = (int32_t *)(4 * v2 + (int32_t)&g56); // 0xf84c
    v3 += *v8;
    *v8 = v3;
    v2++;
    uint32_t v9 = *(int32_t *)((int32_t)&g106 & 0xffff | (int32_t)&g1); // 0xf878
    while (v2 < v9) {
        // 0xf80c
        v4 = 8 * v2;
        v5 = v4 + (int32_t)&g55;
        v6 = *(int64_t *)v5;
        v7 = v6;
        result2 = tadd(v6 >> 32, v7, v3);
        *(int32_t *)v5 = result2;
        *(int32_t *)(v4 + (int32_t)&g55 + 4) = v7;
        v8 = (int32_t *)(4 * v2 + (int32_t)&g56);
        v3 += *v8;
        *v8 = v3;
        v2++;
        v9 = *(int32_t *)((int32_t)&g106 & 0xffff | (int32_t)&g1);
    }
    // 0xf884
    return result2;
}

// Address range: 0xf888 - 0xfa1c
int32_t yearistype(int32_t a1, int32_t a2) {
    // 0xf888
    int32_t v1; // 0xf888
    if (a2 == 0 || (char)v1 == 0) {
        // 0xfa10
        return 1;
    }
    int32_t len = strlen(g62); // 0xf8dc
    char * str = (char *)a2; // 0xf8e8
    int32_t len2 = strlen(str); // 0xf8e8
    int32_t str2 = memcheck(irealloc((int32_t)g104, len + 132 + len2)); // 0xf90c
    *(int32_t *)&g104 = str2;
    sprintf((char *)str2, "%s %d %s", g62, a1, str);
    uint32_t system_rc = system(g104); // 0xf968
    if (system_rc % 128 == 0) {
        // 0xf988
        switch ((char)(system_rc / 256)) {
            case 0: {
                // 0xfa10
                return 1;
            }
            case 1: {
                // 0xfa10
                return 0;
            }
        }
    }
    // 0xf9c0
    error((int32_t)"Wild result from command execution");
    fprintf(g21, "%s: command was '%s', result was %d\n", g39, g104, system_rc);
    exit(1);
    // UNREACHABLE
}

// Address range: 0xfa1c - 0xfa90
int32_t lowerit(uint32_t a1) {
    int32_t c = (uint32_t)(a1 % 256); // 0xfa30
    if ((a1 & 128) != 0) {
        // 0xfa84
        return c;
    }
    int32_t result = c; // 0xfa6c
    if (*(int16_t *)(g17 + 2 * c) % 2 != 0) {
        // 0xfa70
        result = tolower(c);
    }
    // 0xfa84
    return result;
}

// Address range: 0xfa90 - 0xfafc
int32_t ciequal(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1; // 0xfaa0
    int32_t v2 = a2; // 0xfaa0
    char * v3 = (char *)v1; // 0xfac0
    int32_t v4 = lowerit((int32_t)*v3); // 0xfac8
    int32_t result = 0; // 0xfaec
    while (v4 == lowerit((int32_t)*(char *)v2)) {
        // 0xfaa4
        v1++;
        v2++;
        result = 1;
        if (*v3 == 0) {
            // break -> 0xfaf4
            break;
        }
        v3 = (char *)v1;
        v4 = lowerit((int32_t)*v3);
        result = 0;
    }
    // 0xfaf4
    return result;
}

// Address range: 0xfafc - 0xfba4
int32_t itsabbr(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0xfafc
    int32_t v1; // 0xfafc
    int32_t v2 = lowerit(v1 % 256); // 0xfb14
    if (v2 != lowerit((uint32_t)v1 % 256)) {
        // 0xfb9c
        return 0;
    }
    int32_t v3 = a1 + 1; // 0xfb88
    char * v4 = (char *)v3; // 0xfb8c
    int32_t result = 1; // 0xfb94
    if (*v4 == 0) {
      lab_0xfb9c:
        // 0xfb9c
        return result;
    }
    int32_t v5 = v3; // 0xfb88
    int32_t v6 = a2 + 1; // 0xfafc
    unsigned char v7 = *(char *)v6; // 0xfb44
    result = 0;
    if (v7 == 0) {
        return result;
    }
    int32_t v8 = v6 + 1; // 0xfb5c
    int32_t v9 = lowerit((int32_t)v7); // 0xfb68
    v6 = v8;
    while (v9 != lowerit((int32_t)*v4)) {
        // 0xfb44
        v7 = *(char *)v6;
        result = 0;
        if (v7 == 0) {
            return result;
        }
        // 0xfb58
        v8 = v6 + 1;
        v9 = lowerit((int32_t)v7);
        v6 = v8;
    }
    // 0xfb88
    v5++;
    char * v10 = (char *)v5; // 0xfb8c
    while (*v10 != 0) {
        // 0xfb44
        v7 = *(char *)v8;
        result = 0;
        if (v7 == 0) {
            return result;
        }
        // 0xfb58
        v8++;
        v9 = lowerit((int32_t)v7);
        v6 = v8;
        while (v9 != lowerit((int32_t)*v10)) {
            // 0xfb44
            v7 = *(char *)v6;
            result = 0;
            if (v7 == 0) {
                return result;
            }
            // 0xfb58
            v8 = v6 + 1;
            v9 = lowerit((int32_t)v7);
            v6 = v8;
        }
        // 0xfb88
        v5++;
        v10 = (char *)v5;
    }
    // 0xfb9c
    return 1;
}

// Address range: 0xfba4 - 0xfc64
int32_t byword(int32_t a1, char (**a2)[5]) {
    // 0xfba4
    if (a1 == 0 || a2 == NULL) {
        // 0xfc5c
        return 0;
    }
    int32_t v1 = (int32_t)a2;
    char (*v2)[5] = *a2;
    int32_t v3 = (int32_t)v2; // 0xfc04
    if (v2 == NULL) {
        // 0xfc5c
        return 0;
    }
    int32_t v4 = v1; // 0xfc04
    int32_t result = v4; // 0xfbec
    int32_t v5; // 0xfba4
    int32_t v6; // 0xfba4
    int32_t v7; // 0xfba4
    int32_t v8; // 0xfba4
    while (ciequal(a1, v3, v8, v3) == 0) {
        // 0xfbf8
        v4 += 8;
        v3 = *(int32_t *)v4;
        if (v3 == 0) {
            char (*v9)[5] = *a2;
            v5 = (int32_t)v9;
            v7 = v1;
            v6 = 0;
            result = 0;
            if (v9 == NULL) {
                return result;
            } else {
                goto lab_0xfc14;
            }
        }
        result = v4;
    }
  lab_0xfc5c:
    // 0xfc5c
    return result;
  lab_0xfc14:;
    int32_t v10 = v6;
    int32_t v11 = v7;
    int32_t v12 = v5;
    int32_t v13 = v10; // 0xfc2c
    if (itsabbr(a1, v12, v8, v12) == 0) {
        goto lab_0xfc48;
    } else {
        // 0xfc30
        v13 = v11;
        result = 0;
        if (v10 == 0) {
            goto lab_0xfc48;
        } else {
            return result;
        }
    }
  lab_0xfc48:;
    int32_t v14 = v11 + 8; // 0xfc48
    int32_t v15 = *(int32_t *)v14; // 0xfc4c
    v5 = v15;
    v7 = v14;
    v6 = v13;
    result = v13;
    if (v15 == 0) {
        return result;
    } else {
        goto lab_0xfc14;
    }
}

// Address range: 0xfc64 - 0xfe48
int32_t getfields(int32_t * str) {
    // 0xfc64
    if (str == NULL) {
        // 0xfe40
        return 0;
    }
    int32_t len = strlen((char *)str); // 0xfc84
    int32_t result = memcheck(imalloc(4 * len + 4)); // 0xfca4
    int32_t v1 = (int32_t)str; // 0xfcb0
    int32_t v2 = 0; // 0xfcb0
    int32_t v3; // 0xfc64
    while (true) {
        // 0xfcb8
        v3 = v2;
        int32_t v4 = v1;
        char v5 = *(char *)v4;
        int32_t v6 = v4; // 0xfcc4
        char v7 = v5; // 0xfcc4
        if (v5 > -1) {
            char v8 = v5;
            int32_t v9 = v4;
            v6 = v9;
            v7 = v8;
            while ((*(int16_t *)(2 * (int32_t)v8 + g17) & 32) != 0) {
                int32_t v10 = v9 + 1; // 0xfcb4
                v8 = *(char *)v10;
                v6 = v10;
                v7 = v8;
                if (v8 <= 255) {
                    // break -> 0xfcf0
                    break;
                }
                v9 = v10;
                v6 = v9;
                v7 = v8;
            }
        }
        // 0xfcf0
        switch (v7) {
            case 0: {
            }
            case 35: {
                // 0xfe28
                *(int32_t *)(4 * v3 + result) = 0;
                // 0xfe40
                return result;
            }
        }
        // 0xfd08
        v2 = v3 + 1;
        *(int32_t *)(4 * v3 + result) = v6;
        char v11 = *(char *)v6; // 0xfd1c
        int32_t v12 = v6; // 0xfd1c
        int32_t v13 = v6; // 0xfd1c
        int16_t v14; // 0xfc64
        int32_t v15; // 0xfc64
        int32_t v16; // 0xfc64
        unsigned char v17; // 0xfc64
        while (true) {
          lab_0xfd20:;
            int32_t v18 = v13;
            int32_t v19 = v12 + 1; // 0xfd24
            *(char *)v18 = v11;
            int32_t v20 = v19; // 0xfd38
            int32_t v21 = v18; // 0xfd38
            int32_t v22; // 0xfc64
            int32_t v23; // 0xfc64
            if (v11 == 34) {
                while (true) {
                  lab_0xfd70:;
                    int32_t v24 = v21;
                    int32_t v25 = v20 + 1; // 0xfd74
                    char v26 = *(char *)v20; // 0xfd78
                    *(char *)v24 = v26;
                    v22 = v25;
                    v23 = v24;
                    switch (v26) {
                        case 34: {
                            goto lab_0xfd8c;
                        }
                        case 0: {
                            // 0xfd5c
                            error((int32_t)"Odd number of quotation marks");
                            exit(1);
                            // UNREACHABLE
                        }
                        default: {
                            // 0xfd54
                            v20 = v25;
                            v21 = v24 + 1;
                            goto lab_0xfd70;
                        }
                    }
                }
            } else {
                // 0xfd3c
                v22 = v19;
                v23 = v18 + 1;
            }
          lab_0xfd8c:
            // 0xfd8c
            v16 = v23;
            v15 = v22;
            v17 = *(char *)v15;
            switch (v17) {
                case 0: {
                    goto lab_0xfdec;
                }
                case 35: {
                    goto lab_0xfdec;
                }
                default: {
                    if (v17 > -1) {
                        int16_t v27 = *(int16_t *)(g17 + 2 * (int32_t)v17) & 32;
                        v14 = v27;
                        if (v27 != 0) {
                            goto lab_0xfe18;
                        }
                    }
                    // 0xfd20
                    v11 = v17;
                    v12 = v15;
                    v13 = v16;
                    goto lab_0xfd20;
                }
            }
        }
      lab_0xfdec:
        // 0xfdec
        v14 = *(int16_t *)(g17 + 2 * (int32_t)v17) & 32;
      lab_0xfe18:
        // 0xfe18
        *(char *)v16 = 0;
        v1 = v15 + (int32_t)(v14 != 0);
    }
    // 0xfe28
    *(int32_t *)(4 * v3 + result) = 0;
    // 0xfe40
    return result;
}

// Address range: 0xfe48 - 0xfebc
int32_t oadd(int32_t a1, int32_t a2) {
    int32_t result = a2 + a1; // 0xfe64
    if (a2 >= 1 && result <= a1) {
        // 0xfe98
        error((int32_t)"time overflow");
        exit(1);
        // UNREACHABLE
    }
    if (a2 > -1 || result < a1) {
        // 0xfeac
        return result;
    }
    // 0xfe98
    error((int32_t)"time overflow");
    exit(1);
    // UNREACHABLE
}

// Address range: 0xfebc - 0xffbc
int32_t tadd(int64_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a1;
    uint64_t v2 = *(int64_t *)&g30; // 0xfed8
    if (v1 == (int32_t)v2) {
        int32_t result = v1 >> 31;
        if (a3 >= 1 && result == (int32_t)(v2 / 0x100000000)) {
            // 0xffac
            return result;
        }
    }
    uint64_t v3 = *(int64_t *)&g33; // 0xff10
    int32_t v4; // 0xfebc
    if (v1 == (int32_t)v3) {
        int32_t result2 = v1 >> 31;
        v4 = result2;
        if (a3 < 0 == result2 == (int32_t)(v3 / 0x100000000)) {
            // 0xffac
            return result2;
        }
    } else {
        // .thread7
        v4 = v1 >> 31;
    }
    uint32_t result3 = v4 + a3; // 0xff50
    int32_t v5 = (a3 >> 31) + v1 + (int32_t)(result3 < a3); // 0xff54
    if (a3 >= 1) {
        if (((v1 - v5) % 2 != 0) >= (result3 > v4)) {
            // 0xff90
            error((int32_t)"time overflow");
            exit(1);
            // UNREACHABLE
        }
    }
    // 0xff74
    if (a3 >= 0) {
        // 0xffac
        return result3;
    }
    uint64_t v6 = 0x100000000 * a1 >> 32; // 0xff80
    if (((v5 - (int32_t)v6) % 2 != 0) < (result3 < (int32_t)(v6 / 0x100000000))) {
        // 0xffac
        return result3;
    }
    // 0xff90
    error((int32_t)"time overflow");
    exit(1);
    // UNREACHABLE
}

// Address range: 0xffbc - 0x105a8
int32_t rpytime(int32_t * a1, int32_t a2) {
    struct _TYPEDEF_lldiv_t v1; // 0x104d4
    struct _TYPEDEF_lldiv_t v2; // 0x10524
    int32_t v3 = 0; // 0x10138
    int32_t v4 = 1970;
    int32_t v5 = 0; // 0xffbc
    int32_t v6; // 0xffbc
    int32_t v7; // 0xffbc
    int32_t v8; // 0xffbc
    int32_t v9; // 0x1009c
    switch (a2) {
        case -0x80000000: {
            // 0x1059c
            return (int32_t)(*(int64_t *)&g33 / 0x100000000);
        }
        case 0x7fffffff: {
            // 0x1059c
            return (int32_t)(*(int64_t *)&g30 / 0x100000000);
        }
        case 1970: {
            goto lab_0x10200_2;
        }
        default: {
            while (true) {
              lab_0x1000c:
                // 0x1000c
                v6 = v4;
                if (v6 < a2) {
                    if (v6 % 4 == 0) {
                        int32_t v10 = (int64_t)v6 * (int64_t)((int32_t)&g105 & 0xffff | 0x51eb0000) / 0x100000000; // 0x1002c
                        int32_t v11 = v6 >> 31; // 0x10034
                        v7 = (int32_t)&g10 + 4;
                        if (v6 == 100 * ((v10 >> 5) - v11)) {
                            // 0x10050
                            v7 = (int32_t)&g10 + 4;
                            if (v6 == 400 * ((v10 >> 7) - v11)) {
                                goto lab_0x10088;
                            } else {
                                // 0x10084
                                v7 = &g10;
                                goto lab_0x10088;
                            }
                        } else {
                            goto lab_0x10088;
                        }
                    } else {
                        // 0x10084
                        v7 = &g10;
                        goto lab_0x10088;
                    }
                } else {
                    // 0x1009c
                    v9 = v6 - 1;
                    if (v9 % 4 == 0) {
                        int32_t v12 = (int64_t)v9 * (int64_t)((int32_t)&g105 & 0xffff | 0x51eb0000) / 0x100000000; // 0x100b8
                        int32_t v13 = v9 >> 31; // 0x100c0
                        v8 = (int32_t)&g10 + 4;
                        if (v9 == 100 * ((v12 >> 5) - v13)) {
                            // 0x100dc
                            v8 = (int32_t)&g10 + 4;
                            if (v9 == 400 * ((v12 >> 7) - v13)) {
                                goto lab_0x10114;
                            } else {
                                // 0x10110
                                v8 = &g10;
                                goto lab_0x10114;
                            }
                        } else {
                            goto lab_0x10114;
                        }
                    } else {
                        // 0x10110
                        v8 = &g10;
                        goto lab_0x10114;
                    }
                }
            }
        }
    }
  lab_0x10088:;
    int32_t v14 = v6 + 1; // 0x10098
    int32_t v15 = *(int32_t *)v7; // 0x10098
    goto lab_0x10124;
  lab_0x10114:
    // 0x10114
    v14 = v9;
    v15 = -*(int32_t *)v8;
    goto lab_0x10124;
  lab_0x10124:
    // 0x10124
    v4 = v14;
    v3 = oadd(v3, eitol(v15));
    v5 = v3;
    if (v4 == a2) {
        // break -> 0x10200
        goto lab_0x10200_2;
    }
    goto lab_0x1000c;
  lab_0x10200_2:;
    int32_t v16 = (int32_t)a1;
    int32_t * v17 = (int32_t *)(v16 + 32); // 0x10200
    int32_t v18; // 0xffbc
    int32_t v19; // 0xffbc
    int32_t v20; // 0xffbc
    if (*v17 == 0) {
        // 0x1020c
        v20 = 0;
        v19 = v5;
        v18 = *(int32_t *)(v16 + 40);
    } else {
        int32_t v21 = (int64_t)a2 * (int64_t)((int32_t)&g105 & 0xffff | 0x51eb0000) / 0x100000000;
        int32_t v22 = a2 >> 31;
        int32_t v23 = a2 % 4 == 0 == (100 * ((v21 >> 5) - v22) != a2 | 400 * ((v21 >> 7) - v22) == a2) ? 12 : 0;
        int32_t v24 = 0;
        int32_t v25 = *(int32_t *)(4 * (v24 + v23) + (int32_t)&g9); // 0x101dc
        int32_t v26 = oadd(v5, eitol(v25)); // 0x101f4
        int32_t v27 = v24 + 1; // 0x101fc
        int32_t v28 = v26; // 0x10208
        while (*v17 != v27) {
            // 0x1014c
            v24 = v27;
            v25 = *(int32_t *)(4 * (v24 + v23) + (int32_t)&g9);
            v26 = oadd(v28, eitol(v25));
            v27 = v24 + 1;
            v28 = v26;
        }
        int32_t v29 = *(int32_t *)(v16 + 40); // 0x1020c
        bool v30 = v29 != 29 | v24 != 0;
        v20 = v30 ? v27 : 1;
        v19 = v26;
        v18 = v30 ? v29 : 29;
        if (!v30 && a2 % 4 == 0 != (100 * ((v21 >> 5) - v22) != a2 || 400 * ((v21 >> 7) - v22) == a2)) {
            // 0x10288
            v20 = 1;
            v19 = v26;
            v18 = 28;
            if (*(int32_t *)(v16 + 36) != 2) {
                // 0x1029c
                error((int32_t)"use of 2/29 in non leap-year");
                exit(1);
                // UNREACHABLE
            }
        }
    }
    int32_t v31 = v18 - 1; // 0x102b0
    int32_t v32 = oadd(v19, eitol(v31)); // 0x102c8
    int32_t * v33 = (int32_t *)(v16 + 36); // 0x102d0
    int32_t v34 = v32; // 0xffbc
    int32_t v35; // 0xffbc
    int32_t v36; // 0xffbc
    int32_t v37; // 0xffbc
    if (*v33 < 3) {
        int32_t v38 = eitol(4); // 0x102ec
        int32_t v39; // 0xffbc
        if (v32 < 0) {
            int32_t v40 = -v32; // 0x10330
            int32_t v41 = v38 + v32 + 7 * (((int32_t)(-0x6db6db6d * (int64_t)v40 / 0x100000000) - v32 >> 2) - (v40 >> 31)); // 0x10360
            v39 = v41 < 0 ? v41 + 7 : v41;
        } else {
            int32_t v42 = v38 + v32; // 0x102fc
            v39 = -7 * ((v42 + (int32_t)(-0x6db6db6d * (int64_t)v42 / 0x100000000) >> 2) - (v42 >> 31)) + v42;
        }
        int32_t * v43 = (int32_t *)(v16 + 44); // 0x103d0
        v35 = v31;
        v36 = v32;
        if (eitol(*v43) != v39) {
            int32_t v44; // 0xffbc
            int32_t v45; // 0xffbc
            int32_t v46; // 0xffbc
            int32_t v47; // 0xffbc
            int32_t v48; // 0x103bc
            if (*v33 == 1) {
                // 0x10384
                v45 = v44 + 1;
                v47 = oadd(v46, 1);
            } else {
                // 0x103ac
                v48 = v39 - 1;
                v45 = v31 - 1;
                v47 = oadd(v32, -1);
            }
            int32_t v49 = v48 < 0 ? 6 : v48;
            int32_t v50 = v47; // 0x103e4
            int32_t v51 = v45; // 0x103e4
            int32_t v52 = v49; // 0x103e4
            v35 = v45;
            v36 = v47;
            while (eitol(*v43) != v49) {
                // 0x10378
                if (*v33 == 1) {
                    // 0x10384
                    v45 = v44 + 1;
                    v47 = oadd(v46, 1);
                } else {
                    // 0x103ac
                    v48 = v52 - 1;
                    v45 = v51 - 1;
                    v47 = oadd(v50, -1);
                }
                // 0x103d0
                v49 = v48 < 0 ? 6 : v48;
                v50 = v47;
                v51 = v45;
                v52 = v49;
                v35 = v45;
                v36 = v47;
            }
        }
        // 0x103e8
        if (v35 < 0) {
            goto lab_0x1048c;
        } else {
            if (a2 % 4 == 0) {
                int32_t v53 = (int64_t)a2 * (int64_t)((int32_t)&g105 & 0xffff | 0x51eb0000) / 0x100000000; // 0x10408
                int32_t v54 = a2 >> 31; // 0x10410
                v37 = 12;
                if (100 * ((v53 >> 5) - v54) == a2) {
                    // 0x1042c
                    v37 = 12;
                    if (400 * ((v53 >> 7) - v54) == a2) {
                        goto lab_0x10464;
                    } else {
                        // 0x10460
                        v37 = 0;
                        goto lab_0x10464;
                    }
                } else {
                    goto lab_0x10464;
                }
            } else {
                // 0x10460
                v37 = 0;
                goto lab_0x10464;
            }
        }
    } else {
        goto lab_0x104ac;
    }
  lab_0x104ac:;
    uint32_t v55 = v34;
    int32_t v56 = v55 < 0;
    int64_t v57 = *(int64_t *)&g33; // 0x104bc
    v1 = __aeabi_ldivmod(v57 >> 32, 0x15180);
    if (((v56 - (int32_t)v57) % 2 != 0) < (v55 < (int32_t)v1.e0)) {
        // 0x1059c
        return (int32_t)(*(int64_t *)&g33 / 0x100000000);
    }
    int64_t v58 = *(int64_t *)&g30; // 0x1050c
    v2 = __aeabi_ldivmod(v58 >> 32, 0x15180);
    int32_t result; // 0xffbc
    if ((((int32_t)v58 - v56) % 2 != 0) < (v55 > (int32_t)v2.e0)) {
        // 0x1053c
        result = (int32_t)(*(int64_t *)&g30 / 0x100000000);
    } else {
        // 0x1054c
        result = tadd(0, 0x15180 * v55 / 0x80000000 + v55 / 0xc22f, *(int32_t *)(v16 + 48));
    }
    // 0x1059c
    return result;
  lab_0x1048c:
    // 0x1048c
    v34 = v36;
    if (g36 != 0) {
        // 0x104a0
        warning("rule goes past start/end of month--will not work with pre-2004 versions of zic");
        v34 = v36;
    }
    goto lab_0x104ac;
  lab_0x10464:;
    int32_t v59 = *(int32_t *)(4 * (v37 + v20) + (int32_t)&g9); // 0x10480
    v34 = v36;
    if (v59 > v35) {
        goto lab_0x104ac;
    } else {
        goto lab_0x1048c;
    }
}

// Address range: 0x105a8 - 0x10840
int32_t newabbr(int32_t a1) {
    char * str = (char *)a1;
    if (strcmp(str, "Local time zone must be set--see zic manual page") != 0) {
        char v1 = *str; // 0x105e4
        char v2 = v1; // 0x105f0
        int32_t v3 = a1; // 0x105f0
        if (v1 > -1) {
            char v4 = v1; // 0x105e4
            int32_t v5 = a1; // 0x105e0
            v2 = v4;
            v3 = v5;
            while ((*(int16_t *)(2 * (int32_t)v4 + g17) & 4) != 0) {
                // 0x105e0
                v5++;
                v4 = *(char *)v5;
                v2 = v4;
                v3 = v5;
                if (v4 <= 255) {
                    // break -> 0x1061c
                    break;
                }
                v2 = v4;
                v3 = v5;
            }
        }
        int32_t v6 = v3 == a1 ? (int32_t)"time zone abbreviation lacks alphabetic at start" : 0;
        int32_t v7 = v3 - a1; // 0x10650
        int32_t v8 = v7 < 4 | g36 == 0 ? v6 : (int32_t)"time zone abbreviation has more than 3 alphabetics";
        int32_t v9 = v7 < 7 ? v8 : (int32_t)"time zone abbreviation has too many alphabetics";
        int32_t v10 = v3; // 0x10684
        if (v9 == 0) {
            // 0x10688
            v10 = v3;
            switch (v2) {
                case 43: {
                }
                case 45: {
                    int32_t v11 = v3 + 1; // 0x106a0
                    unsigned char v12 = *(char *)v11; // 0x106a4
                    v10 = v11;
                    if (v12 > -1) {
                        // 0x106b4
                        v10 = v11;
                        if ((*(int16_t *)(g17 + 2 * (int32_t)v12) & 8) != 0) {
                            int32_t v13 = v3 + 2; // 0x106e0
                            v10 = v13;
                            if (v12 == 49) {
                                unsigned char v14 = *(char *)v13; // 0x106f0
                                v10 = v13;
                                if (v14 != 47 && v14 >= 47) {
                                    // 0x106fc
                                    v10 = v14 >= 52 == (v14 != 52) ? v13 : v3 + 3;
                                }
                            }
                        }
                    }
                    // break -> 0x1070c
                    break;
                }
            }
        }
        char v15 = *(char *)v10; // 0x1070c
        int32_t v16 = v15 == 0 ? v9 : (int32_t)"time zone abbreviation differs from POSIX standard";
        if (v16 != 0) {
            int32_t v17 = memcheck(icpyalloc((char *)v16)); // 0x10738
            int32_t v18 = memcheck(icatalloc(v17, (int32_t)" (")); // 0x10758
            int32_t v19 = memcheck(icatalloc(v18, a1)); // 0x10774
            int32_t v20 = icatalloc(v19, (int32_t)&g15); // 0x10788
            int32_t v21 = memcheck(v20); // 0x10794
            warning((char *)v21);
            ifree(v21);
        }
    }
    int32_t v22 = strlen(str) + 1; // 0x107b8
    if (g22 + v22 >= 51) {
        // 0x107d8
        error((int32_t)"too many, or too long, time zone abbreviations");
        exit(1);
        // UNREACHABLE
    }
    // 0x107ec
    strcpy((char *)(g22 + (int32_t)&g54), str);
    int32_t result = eitol(v22); // 0x10814
    g22 += result;
    return result;
}

// Address range: 0x10840 - 0x1098c
int32_t mkdirs(int32_t a1) {
    // 0x10840
    int32_t v1; // 0x10840
    if (a1 == 0 || (char)v1 == 0) {
        // 0x10980
        return 0;
    }
    int32_t v2 = memcheck(icpyalloc((char *)a1)); // 0x10884
    char * found_char_pos = strchr((char *)(v2 + 1), 47); // 0x10964
    char * err_str; // 0x108d8
    char * path; // 0x10840
    if (found_char_pos != NULL) {
        // 0x10894
        path = (char *)v2;
        char * found_char_pos2 = found_char_pos; // 0x10964
        *found_char_pos2 = 0;
        if (itsdir(v2) == 0) {
            // 0x108b0
            if (mkdir(path, 493) != 0) {
                // 0x108c8
                err_str = strerror(*__errno_location());
                if (*__errno_location() != 17) {
                    goto lab_0x10908_2;
                }
                // 0x108f4
                if (itsdir(v2) == 0) {
                    goto lab_0x10908_2;
                }
            }
        }
        // 0x10950
        *found_char_pos2 = 47;
        found_char_pos2 = strchr((char *)((int32_t)found_char_pos2 + 1), 47);
        while (found_char_pos2 != NULL) {
            // 0x10894
            *found_char_pos2 = 0;
            if (itsdir(v2) == 0) {
                // 0x108b0
                if (mkdir(path, 493) != 0) {
                    // 0x108c8
                    err_str = strerror(*__errno_location());
                    if (*__errno_location() != 17) {
                        goto lab_0x10908_2;
                    }
                    // 0x108f4
                    if (itsdir(v2) == 0) {
                        goto lab_0x10908_2;
                    }
                }
            }
            // 0x10950
            *found_char_pos2 = 47;
            found_char_pos2 = strchr((char *)((int32_t)found_char_pos2 + 1), 47);
        }
    }
    // 0x10974
    ifree(v2);
    int32_t result = 0; // 0x1097c
    // 0x10980
    return result;
  lab_0x10908_2:
    // 0x10908
    fprintf(g21, "%s: Can't create directory %s: %s\n", g39, path, err_str);
    ifree(v2);
    result = -1;
    return result;
}

// Address range: 0x1098c - 0x10a34
int32_t eitol(int32_t result) {
    // 0x1098c
    return result;
}

// Address range: 0x14e10 - 0x15030
int32_t scheck(int32_t str2, char * str) {
    // 0x14e10
    if (str2 == 0 || str == NULL) {
        // 0x15024
        return &g16;
    }
    int32_t format = imalloc(2 * strlen(str) + 4); // 0x14e64
    if (format == 0) {
        // 0x15024
        return &g16;
    }
    int32_t v1 = (int32_t)str; // 0x14e7c
    int32_t v2 = v1; // 0x14e84
    int32_t v3 = format; // 0x14e84
    int32_t v4; // 0x14e10
    int32_t items_assigned; // 0x15004
    while (true) {
        int32_t v5 = v3;
        int32_t v6 = v2;
        int32_t v7 = v5 + 1; // 0x14fa8
        int32_t v8 = v6 + 1; // 0x14fb0
        char v9 = *(char *)v6; // 0x14fb4
        *(char *)v5 = v9;
        v2 = v8;
        v3 = v7;
        v4 = v7;
        switch (v9) {
            case 0: {
                // 0x14fd0
                *(char *)(v4 - 1) = 37;
                *(char *)v4 = 99;
                *(char *)(v4 + 1) = 0;
                items_assigned = sscanf((char *)str2, (char *)format);
                ifree(format);
                // 0x15024
                return items_assigned == 1 ? (int32_t)&g16 : v1;
            }
            case 37: {
                char * v10 = (char *)v8; // 0x14e94
                int32_t v11 = v5 + 2;
                if (*v10 == 37) {
                    // 0x14ea0
                    *(char *)v7 = 37;
                    v2 = v6 + 2;
                    v3 = v11;
                } else {
                    // 0x14ebc
                    *(char *)v7 = 42;
                    int32_t v12 = *v10 == 42 ? v6 + 2 : v8;
                    char v13 = *(char *)v12; // 0x14efc
                    uint32_t v14 = (int32_t)v13 - 48; // 0x14f00
                    char v15 = v13; // 0x14f08
                    int32_t v16 = v11; // 0x14f08
                    int32_t v17 = v12; // 0x14f08
                    int32_t v18 = v12; // 0x14f08
                    int32_t v19 = v11; // 0x14f08
                    char v20 = v13; // 0x14f08
                    if (v14 == 9 || v14 < 9) {
                        int32_t v21 = v16 + 1; // 0x14ee8
                        int32_t v22 = v17 + 1; // 0x14ef0
                        *(char *)v16 = v15;
                        char v23 = *(char *)v22; // 0x14efc
                        uint32_t v24 = (int32_t)v23 - 48; // 0x14f00
                        v16 = v21;
                        v17 = v22;
                        v18 = v22;
                        v19 = v21;
                        v20 = v23;
                        while (v24 == 9 || v24 < 9) {
                            // 0x14ee4
                            v21 = v16 + 1;
                            v22 = v17 + 1;
                            *(char *)v16 = v23;
                            v23 = *(char *)v22;
                            v24 = (int32_t)v23 - 48;
                            v16 = v21;
                            v17 = v22;
                            v18 = v22;
                            v19 = v21;
                            v20 = v23;
                        }
                    }
                    char v25 = v20; // 0x14f34
                    int32_t v26 = v19;
                    int32_t v27 = v18;
                    char v28 = 91; // 0x14e10
                    int32_t v29 = v27; // 0x14e10
                    int32_t v30 = v26; // 0x14e10
                    char v31 = v25; // 0x14e10
                    int32_t v32 = v27; // 0x14e10
                    int32_t v33 = v26; // 0x14e10
                    switch (v25) {
                        case 108: {
                        }
                        case 104: {
                            int32_t v34 = v27 + 1; // 0x14f30
                            *(char *)v26 = v25;
                            v31 = *(char *)v34;
                            v32 = v34;
                            v33 = v26 + 1;
                            // break -> 0x14f7c
                            break;
                        }
                        case 91: {
                            while (true) {
                              lab_0x14f4c:;
                                int32_t v35 = v30 + 1; // 0x14f50
                                int32_t v36 = v29 + 1; // 0x14f58
                                *(char *)v30 = v28;
                                char v37 = *(char *)v36; // 0x14f64
                                v28 = v37;
                                v29 = v36;
                                v30 = v35;
                                v31 = v37;
                                v32 = v36;
                                v33 = v35;
                                switch (v37) {
                                    case 0: {
                                        goto lab_0x14f7c;
                                    }
                                    case 93: {
                                        goto lab_0x14f7c;
                                    }
                                    default: {
                                        goto lab_0x14f4c;
                                    }
                                }
                            }
                        }
                    }
                  lab_0x14f7c:
                    // 0x14f7c
                    *(char *)v33 = v31;
                    v2 = v32 + 1;
                    v3 = v33 + 1;
                    if (v31 == 0) {
                        // break -> 0x14fd0
                        break;
                    }
                }
                // break -> 0x14fa4
                break;
            }
        }
    }
    // 0x14fd0
    *(char *)(v4 - 1) = 37;
    *(char *)v4 = 99;
    *(char *)(v4 + 1) = 0;
    items_assigned = sscanf((char *)str2, (char *)format);
    ifree(format);
    // 0x15024
    return items_assigned == 1 ? (int32_t)&g16 : v1;
}

// Address range: 0x15030 - 0x15070
int32_t imalloc(int32_t a1) {
    // 0x15030
    return (int32_t)malloc(a1 == 0 ? 1 : a1);
}

// Address range: 0x150d0 - 0x15134
int32_t irealloc(int32_t a1, int32_t a2) {
    int32_t mem; // 0x150d0
    if (a1 == 0) {
        // 0x150f0
        mem = imalloc(a2);
    } else {
        // 0x15100
        mem = (int32_t)realloc((int32_t *)a1, a2 == 0 ? 1 : a2);
    }
    // 0x15128
    return mem;
}

// Address range: 0x15134 - 0x151f0
int32_t icatalloc(int32_t str2, int32_t str) {
    int32_t len = 0; // 0x15150
    if (str != 0) {
        // 0x15154
        len = strlen((char *)str);
    }
    int32_t len2 = 0; // 0x15174
    if (str2 != 0) {
        // 0x15180
        if (len == 0) {
            // 0x151e4
            return str2;
        }
        // 0x15190
        len2 = strlen((char *)str2);
    }
    int32_t result = irealloc(str2, len + 1 + len2); // 0x151b0
    if (str != 0 && result != 0) {
        // 0x151cc
        strcpy((char *)(result + len2), (char *)str);
    }
    // 0x151e4
    return result;
}

// Address range: 0x151f0 - 0x1521c
int32_t icpyalloc(char * a1) {
    // 0x151f0
    return icatalloc(0, (int32_t)a1);
}

// Address range: 0x1521c - 0x15248
int32_t ifree(int32_t a1) {
    int32_t result = 0; // 0x15234
    if (a1 != 0) {
        // 0x15238
        free((int32_t *)a1);
        result = &g112;
    }
    // 0x15240
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (3.3.2)
// Detected functions: 54


