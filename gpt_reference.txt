
This is example2/hacknote.c.
//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t add_note(void);
int32_t del_note(void);
int32_t menu(void);
int32_t print_note(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x804a060
struct _IO_FILE * g2 = NULL; // 0x804a064
int32_t g3 = 0; // 0x804a06c
int32_t g4 = 0; // 0x804a070
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x8048676 - 0x8048804
int32_t add_note(void) {
    int32_t v1 = __readgsdword(20); // 0x804867d
    int32_t v2 = 0; // 0x8048690
    if (g3 < 6) {
        int32_t * v3 = (int32_t *)(4 * v2 + (int32_t)&g4);
        while (*v3 != 0) {
            // 0x80487e4
            v2++;
            if (v2 >= 5) {
                goto lab_0x80487ee;
            }
            v3 = (int32_t *)(4 * v2 + (int32_t)&g4);
        }
        int32_t * mem = malloc(8); // 0x80486ca
        *v3 = (int32_t)mem;
        if (mem == NULL) {
            // 0x80486ec
            puts("Alloca Error");
            exit(-1);
            // UNREACHABLE
        }
        // 0x8048706
        *mem = 0x804865b;
        printf("Note size :");
        int32_t buf; // bp-24, 0x8048676
        read(0, &buf, 8);
        int32_t str_as_i = atoi((char *)&buf); // 0x8048740
        *(int32_t *)(*v3 + 4) = (int32_t)malloc(str_as_i);
        if (*(int32_t *)(*v3 + 4) == 0) {
            // 0x8048778
            puts("Alloca Error");
            exit(-1);
            // UNREACHABLE
        }
        // 0x8048792
        printf("Content :");
        read(0, (int32_t *)*(int32_t *)(*v3 + 4), str_as_i);
        puts("Success !");
        g3++;
    } else {
        // 0x8048692
        puts("Full");
    }
  lab_0x80487ee:;
    int32_t result = 0; // 0x80487f8
    if (v1 != __readgsdword(20)) {
        // 0x80487fa
        __stack_chk_fail();
        result = &g5;
    }
    // 0x80487ff
    return result;
}

// Address range: 0x8048804 - 0x80488d5
int32_t del_note(void) {
    int32_t v1 = __readgsdword(20); // 0x804880a
    printf("Index :");
    int32_t buf; // bp-20, 0x8048804
    read(0, &buf, 4);
    int32_t str_as_i = atoi((char *)&buf); // 0x804883f
    if (str_as_i > -1 != str_as_i < g3) {
        // 0x804885a
        puts("Out of bound!");
        _exit(0);
        // UNREACHABLE
    }
    int32_t * v2 = (int32_t *)(4 * str_as_i + (int32_t)&g4); // 0x8048877
    int32_t v3 = *v2; // 0x8048877
    if (v3 != 0) {
        // 0x8048882
        free((int32_t *)*(int32_t *)(v3 + 4));
        free((int32_t *)*v2);
        puts("Success");
    }
    int32_t result = 0; // 0x80488cc
    if (v1 != __readgsdword(20)) {
        // 0x80488ce
        __stack_chk_fail();
        result = &g5;
    }
    // 0x80488d3
    return result;
}

// Address range: 0x80488d5 - 0x8048986
int32_t print_note(void) {
    int32_t v1 = __readgsdword(20); // 0x80488db
    printf("Index :");
    int32_t buf; // bp-20, 0x80488d5
    read(0, &buf, 4);
    int32_t str_as_i = atoi((char *)&buf); // 0x8048910
    if (str_as_i > -1 != str_as_i < g3) {
        // 0x804892b
        puts("Out of bound!");
        _exit(0);
        // UNREACHABLE
    }
    int32_t result = 0; // 0x804897d
    if (v1 != __readgsdword(20)) {
        // 0x804897f
        __stack_chk_fail();
        result = &g5;
    }
    // 0x8048984
    return result;
}

// Address range: 0x804899f - 0x8048a38
int32_t menu(void) {
    // 0x804899f
    puts("----------------------");
    puts("       HackNote       ");
    puts("----------------------");
    puts(" 1. Add note          ");
    puts(" 2. Delete note       ");
    puts(" 3. Print note        ");
    puts(" 4. Exit              ");
    puts("----------------------");
    return printf("Your choice :");
}

// Address range: 0x8048a38 - 0x8048af2
int main(int argc, char ** argv) {
    // 0x8048a38
    __readgsdword(20);
    setvbuf(g2, NULL, 2, 0);
    setvbuf((struct _IO_FILE *)g1, NULL, 2, 0);
    int32_t v1; // bp-32, 0x8048a38
    int32_t v2 = &v1; // 0x8048a79
    int32_t v3; // bp-24, 0x8048a38
    int32_t v4 = &v3;
    int32_t * v5 = (int32_t *)(v2 - 16);
    while (true) {
      lab_0x8048a7c:
        // 0x8048a7c
        menu();
        *(int32_t *)(v2 - 8) = 4;
        *(int32_t *)(v2 - 12) = v4;
        *v5 = 0;
        read((int32_t)&g5, &g5, (int32_t)&g5);
        *v5 = v4;
        int32_t str_as_i = atoi((char *)&g5); // 0x8048a9b
        if (str_as_i == 2) {
            // 0x8048ac7
            del_note();
            goto lab_0x8048a7c;
        } else {
            if (str_as_i > 2) {
                switch (str_as_i) {
                    case 3: {
                        // 0x8048ace
                        print_note();
                        goto lab_0x8048a7c;
                    }
                    case 4: {
                        goto lab_0x8048ad5;
                    }
                    default: {
                        goto lab_0x8048adf;
                    }
                }
            } else {
                if (str_as_i == 1) {
                    // 0x8048ac0
                    add_note();
                    goto lab_0x8048a7c;
                } else {
                    goto lab_0x8048adf;
                }
            }
        }
    }
  lab_0x8048ad5:
    // 0x8048ad5
    *v5 = 0;
    exit((int32_t)&g5);
    // UNREACHABLE
  lab_0x8048adf:
    // 0x8048adf
    *v5 = (int32_t)"Invalid choice";
    puts((char *)&g5);
    goto lab_0x8048a7c;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (5.4.0)
// Detected functions: 5


