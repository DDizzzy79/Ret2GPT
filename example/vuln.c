//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t function_401000(void);
void function_401030(int64_t * ptr);
int32_t function_401040(char * s);
int32_t function_401050(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
int32_t function_401060(struct _IO_FILE * stream);
void function_401070(void);
void function_401080(struct _IO_FILE * stream, char * buf);
int32_t function_401090(char * command);
int32_t function_4010a0(char * format, ...);
int32_t function_4010b0(char * string, int32_t maxlen);
void function_4010c0(int32_t seed);
int32_t function_4010d0(int32_t c, struct _IO_FILE * stream);
int32_t function_4010e0(void);
int64_t * function_4010f0(int32_t size);
struct _IO_FILE * function_401100(char * filename, char * modes);
int32_t function_401110(char * format, ...);
int32_t function_401120(char * s, char * format, ...);
int32_t function_401130(void);
int64_t function_401170(void);
int64_t function_401180(void);
int64_t function_4011b0(void);
int64_t function_4011f0(void);
int64_t function_401220(void);
int64_t function_401226(int64_t a1, int64_t a2);
int64_t function_40130f(int64_t a1);
int64_t function_40137f(int64_t a1);
int64_t function_401551(int64_t a1);
int64_t function_401660(int64_t a1);
int64_t function_4016b1(int64_t a1);
int64_t function_401715(int64_t a1);
int64_t function_4017af(int64_t a1);
int64_t function_401854(int64_t a1);
int64_t function_401a39(int64_t a1);
int64_t function_401b4d(void);
int64_t function_401c0c(int64_t a1, int64_t a2);
int64_t function_401e50(int64_t a1, int64_t a2, int64_t a3);
int64_t function_401eb0(void);
int64_t function_401eb4(void);
int64_t sleep(int64_t a1);

// --------------------- Global Variables ---------------------

int64_t g1 = -0x57f0000059b; // 0x402288
int64_t g2 = 0x401220; // 0x403e00
int64_t g3 = 0x4011f0; // 0x403e08
int64_t g4 = 0; // 0x403ff8
struct _IO_FILE * g5 = NULL; // 0x4040c0
struct _IO_FILE * g6 = NULL; // 0x4040d0
struct _IO_FILE * g7 = NULL; // 0x4040e0
char g8 = 0; // 0x4040e8
int32_t g9;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x401017
int64_t function_401000(void) {
    int64_t result = 0; // 0x40100e
    if (g4 != 0) {
        // 0x401010
        __gmon_start__();
        result = &g9;
    }
    // 0x401012
    return result;
}

// Address range: 0x401030 - 0x401036
void function_401030(int64_t * ptr) {
    // 0x401030
    free(ptr);
}

// Address range: 0x401040 - 0x401046
int32_t function_401040(char * s) {
    // 0x401040
    return puts(s);
}

// Address range: 0x401050 - 0x401056
int32_t function_401050(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x401050
    return fread(ptr, size, n, stream);
}

// Address range: 0x401060 - 0x401066
int32_t function_401060(struct _IO_FILE * stream) {
    // 0x401060
    return fclose(stream);
}

// Address range: 0x401070 - 0x401076
void function_401070(void) {
    // 0x401070
    __stack_chk_fail();
}

// Address range: 0x401080 - 0x401086
void function_401080(struct _IO_FILE * stream, char * buf) {
    // 0x401080
    setbuf(stream, buf);
}

// Address range: 0x401090 - 0x401096
int32_t function_401090(char * command) {
    // 0x401090
    return system(command);
}

// Address range: 0x4010a0 - 0x4010a6
int32_t function_4010a0(char * format, ...) {
    // 0x4010a0
    return printf(format);
}

// Address range: 0x4010b0 - 0x4010b6
int32_t function_4010b0(char * string, int32_t maxlen) {
    // 0x4010b0
    return strnlen(string, maxlen);
}

// Address range: 0x4010c0 - 0x4010c6
void function_4010c0(int32_t seed) {
    // 0x4010c0
    srand(seed);
}

// Address range: 0x4010d0 - 0x4010d6
int32_t function_4010d0(int32_t c, struct _IO_FILE * stream) {
    // 0x4010d0
    return putc(c, stream);
}

// Address range: 0x4010e0 - 0x4010e6
int32_t function_4010e0(void) {
    // 0x4010e0
    return getchar();
}

// Address range: 0x4010f0 - 0x4010f6
int64_t * function_4010f0(int32_t size) {
    // 0x4010f0
    return malloc(size);
}

// Address range: 0x401100 - 0x401106
struct _IO_FILE * function_401100(char * filename, char * modes) {
    // 0x401100
    return fopen(filename, modes);
}

// Address range: 0x401110 - 0x401116
int32_t function_401110(char * format, ...) {
    // 0x401110
    return scanf(format);
}

// Address range: 0x401120 - 0x401126
int32_t function_401120(char * s, char * format, ...) {
    // 0x401120
    return sprintf(s, format);
}

// Address range: 0x401130 - 0x401136
int32_t function_401130(void) {
    // 0x401130
    return rand();
}

// Address range: 0x401140 - 0x40116b
int64_t entry_point(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x401140
    int64_t v1; // 0x401140
    __libc_start_main(0x401c0c, (int32_t)a4, (char **)&v1, (void (*)())0x401e50, (void (*)())0x401eb0, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x401170 - 0x401171
int64_t function_401170(void) {
    // 0x401170
    int64_t result; // 0x401170
    return result;
}

// Address range: 0x401180 - 0x4011a1
int64_t function_401180(void) {
    // 0x401180
    return 0x4040b0;
}

// Address range: 0x4011b0 - 0x4011e1
int64_t function_4011b0(void) {
    // 0x4011b0
    return 0;
}

// Address range: 0x4011f0 - 0x401211
int64_t function_4011f0(void) {
    // 0x4011f0
    if (g8 != 0) {
        // 0x401210
        int64_t result; // 0x4011f0
        return result;
    }
    int64_t result2 = function_401180(); // 0x401201
    g8 = 1;
    return result2;
}

// Address range: 0x401220 - 0x401226
int64_t function_401220(void) {
    // 0x401220
    return function_4011b0();
}

// Address range: 0x401226 - 0x4012b3
int64_t function_401226(int64_t a1, int64_t a2) {
    // 0x401226
    printf("Enter a string of %d characters: ", a2 & 0xffffffff);
    int32_t v1 = a2; // 0x401293
    int32_t v2 = 0; // 0x401296
    int64_t result = a1; // 0x401296
    if (v1 <= 0) {
      lab_0x401299:
        // 0x401299
        while (true) {
            // 0x401299
            if ((char)getchar() == 10) {
                // break -> 0x4012a7
                break;
            }
        }
        // 0x4012a7
        *(char *)result = 0;
        // 0x4012b1
        return result;
    }
    int64_t v3 = a1;
    int32_t c = getchar(); // 0x40125c
    char v4 = c;
    int32_t result2 = c; // 0x401272
    char v5 = v4; // 0x401272
    char v6; // 0x401226
    int32_t c2; // 0x401266
    if (v4 == 10) {
        c2 = getchar();
        v6 = c2;
        result2 = c2;
        v5 = v6;
        while (v6 == 10) {
            // 0x401266
            c2 = getchar();
            v6 = c2;
            result2 = c2;
            v5 = v6;
        }
    }
    while (v5 != -1) {
        int64_t v7 = v3 + 1; // 0x40127e
        *(char *)v3 = v5;
        v2++;
        result = v7;
        if (v2 >= v1) {
            goto lab_0x401299;
        }
        v3 = v7;
        c = getchar();
        v4 = c;
        result2 = c;
        v5 = v4;
        if (v4 == 10) {
            c2 = getchar();
            v6 = c2;
            result2 = c2;
            v5 = v6;
            while (v6 == 10) {
                // 0x401266
                c2 = getchar();
                v6 = c2;
                result2 = c2;
                v5 = v6;
            }
        }
    }
    // 0x4012b1
    return result2;
}

// Address range: 0x4012b3 - 0x40130f
int64_t sleep(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x4012c2
    int64_t str; // bp-40, 0x4012b3
    sprintf((char *)&str, "sleep %d", a1 & 0xffffffff);
    system((char *)&str);
    int64_t result = 0; // 0x401306
    if (v1 != __readfsqword(40)) {
        // 0x401308
        __stack_chk_fail();
        result = &g9;
    }
    // 0x40130d
    return result;
}

// Address range: 0x40130f - 0x40137f
int64_t function_40130f(int64_t a1) {
    int64_t result; // 0x401367
    for (int64_t i = 0; i < 18; i++) {
        int64_t v1 = 16 * i + a1; // 0x401332
        *(int64_t *)v1 = 0;
        *(int32_t *)(v1 + 8) = (int32_t)i;
        result = v1 + 12;
        *(int32_t *)result = 0;
    }
    // 0x40137b
    return result;
}

// Address range: 0x40137f - 0x401551
int64_t function_40137f(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x401390
    int32_t v2 = 0; // bp-40, 0x40139f
    int32_t v3 = 0; // bp-36, 0x4013a6
    printf("Stable index # (0-%d)? ", 17);
    scanf("%d", &v2);
    int64_t v4; // 0x40137f
    if (v2 < 18) {
        int64_t v5 = a1 + 12;
        if (*(int32_t *)(16 * (int64_t)v2 + v5) == 0) {
            // 0x401431
            printf("Horse name length (%d-%d)? ", 16, 256);
            scanf("%d", &v3);
            if (v3 < 257) {
                int64_t * mem = malloc(v3 + 1); // 0x40149a
                *(int64_t *)(16 * (int64_t)v2 + a1) = (int64_t)mem;
                int64_t v6 = *(int64_t *)(16 * (int64_t)v2 + a1); // 0x4014c4
                if (v6 != 0) {
                    // 0x4014df
                    function_401226(v6, (int64_t)v3);
                    *(int32_t *)(16 * (int64_t)v2 + v5) = 1;
                    printf("Added horse to stable index %d\n", (int64_t)v2);
                    v4 = 1;
                } else {
                    // 0x4014cc
                    puts("Failed to allocate memory for horse name");
                    v4 = 0;
                }
            } else {
                // 0x401476
                puts("Invalid horse name length");
                v4 = 0;
            }
        } else {
            // 0x40141b
            puts("Stable location already in use");
            v4 = 0;
        }
    } else {
        // 0x4013ea
        puts("Invalid stable index");
        v4 = 0;
    }
    int64_t result = v4; // 0x401543
    if (v1 != __readfsqword(40)) {
        // 0x401545
        __stack_chk_fail();
        result = &g9;
    }
    // 0x40154a
    return result;
}

// Address range: 0x401551 - 0x401660
int64_t function_401551(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x401561
    int32_t v2 = 0; // bp-20, 0x401570
    printf("Stable index # (0-%d)? ", 17);
    scanf("%d", &v2);
    int64_t v3; // 0x401551
    if (v2 < 18) {
        int64_t v4 = 16 * (int64_t)v2 + a1; // 0x4015d8
        if (*(int32_t *)(v4 + 12) != 0) {
            // 0x4015f8
            free((int64_t *)*(int64_t *)v4);
            *(int32_t *)(a1 + 12 + 16 * (int64_t)v2) = 0;
            printf("Removed horse from stable index %d\n", (int64_t)v2);
            v3 = 1;
        } else {
            // 0x4015e5
            puts("Stable location not in use");
            v3 = 0;
        }
    } else {
        // 0x4015b4
        puts("Invalid stable index");
        v3 = 0;
    }
    int64_t result = v3; // 0x401657
    if (v1 != __readfsqword(40)) {
        // 0x401659
        __stack_chk_fail();
        result = &g9;
    }
    // 0x40165e
    return result;
}

// Address range: 0x401660 - 0x4016b1
int64_t function_401660(int64_t a1) {
    int32_t v1 = 0;
    for (int64_t i = 0; i < 18; i++) {
        int32_t v2 = *(int32_t *)(a1 + 12 + 16 * i); // 0x401691
        v1 += (int32_t)(v2 != 0);
    }
    int32_t v3 = v1 - 4; // 0x4016a5
    return v3 < 0 == (3 - v1 & v1) < 0 == (v3 != 0);
}

// Address range: 0x4016b1 - 0x401715
int64_t function_4016b1(int64_t a1) {
    int64_t v1 = 0;
    int64_t v2 = 16 * v1 + a1; // 0x4016d4
    if (*(int32_t *)(v2 + 12) != 0) {
        // 0x4016e1
        if (*(int32_t *)(v2 + 8) >= 30) {
            // break -> 0x401713
            break;
        }
    }
    // 0x401704
    v1++;
    int64_t result = 0; // 0x40170c
    while (v1 < 18) {
        // 0x4016c6
        v2 = 16 * v1 + a1;
        if (*(int32_t *)(v2 + 12) != 0) {
            // 0x4016e1
            result = 1;
            if (*(int32_t *)(v2 + 8) >= 30) {
                // break -> 0x401713
                break;
            }
        }
        // 0x401704
        v1++;
        result = 0;
    }
    // 0x401713
    return result;
}

// Address range: 0x401715 - 0x4017af
int64_t function_401715(int64_t a1) {
    int32_t v1 = 0;
    int32_t v2 = 0;
    int64_t v3 = 0;
    int64_t v4 = 16 * v3 + a1; // 0x401746
    int32_t v5 = v1; // 0x401751
    int32_t v6 = v2; // 0x401751
    uint32_t v7; // 0x401768
    if (*(int32_t *)(v4 + 12) != 0) {
        // 0x401753
        v7 = *(int32_t *)(v4 + 8);
        v5 = (int64_t)v1 < (int64_t)v7 ? v7 : v1;
        v6 = (int64_t)v1 < (int64_t)v7 ? (int32_t)v3 : v2;
    }
    int32_t v8 = v6;
    int64_t v9 = v3 + 1;
    while (v9 != 18) {
        // 0x401738
        v1 = v5;
        v2 = v8;
        v3 = v9;
        v4 = 16 * v3 + a1;
        v5 = v1;
        v6 = v2;
        if (*(int32_t *)(v4 + 12) != 0) {
            // 0x401753
            v7 = *(int32_t *)(v4 + 8);
            v5 = (int64_t)v1 < (int64_t)v7 ? v7 : v1;
            v6 = (int64_t)v1 < (int64_t)v7 ? (int32_t)v3 : v2;
        }
        // 0x40178f
        v8 = v6;
        v9 = v3 + 1;
    }
    // 0x401799
    return *(int64_t *)(16 * (int64_t)v8 + a1);
}

// Address range: 0x4017af - 0x401854
int64_t function_4017af(int64_t a1) {
    int64_t result; // 0x4017af
    for (int64_t i = 0; i < 18; i++) {
        int64_t v1 = 16 * i + a1; // 0x4017d6
        result = 0;
        if (*(int32_t *)(v1 + 12) != 0) {
            int32_t v2 = rand(); // 0x4017e3
            int64_t v3 = v1 + 8; // 0x401822
            int32_t * v4 = (int32_t *)v3; // 0x401826
            *v4 = v2 + 1 + *v4 + v2 % 5 - v2;
            result = v3;
        }
    }
    // 0x401850
    return result;
}

// Address range: 0x401854 - 0x401a39
int64_t function_401854(int64_t a1) {
    for (int64_t i = 0; i < 18; i++) {
        int64_t v1 = 16 * i + a1; // 0x401885
        if (*(int32_t *)(v1 + 12) == 0) {
            int32_t v2 = 0; // 0x4019e0
            putc(32, g5);
            v2++;
            struct _IO_FILE * stream = g5; // 0x4019e8
            while (v2 != 30) {
                // 0x4019cc
                putc(32, stream);
                v2++;
                stream = g5;
            }
            // 0x4019ea
            putc(124, g5);
        } else {
            int64_t * str = (int64_t *)v1; // 0x4018a7
            int32_t v3 = strnlen((char *)*str, 16); // 0x4018b2
            int32_t * v4 = (int32_t *)(v1 + 8); // 0x4018f0
            int32_t v5 = 0; // 0x4018f5
            if (*v4 != 0) {
                putc(32, g5);
                int32_t v6 = 1; // 0x4018d7
                uint32_t v7 = *v4; // 0x4018f0
                int32_t v8 = v6; // 0x4018f5
                v5 = v7;
                while ((int64_t)v6 < (int64_t)v7) {
                    // 0x4018c3
                    putc(32, g5);
                    v6 = v8 + 1;
                    v7 = *v4;
                    v8 = v6;
                    v5 = v7;
                }
            }
            int32_t v9 = v5; // 0x40193d
            if (v3 > 0) {
                int64_t v10 = 0;
                putc((int32_t)*(char *)(*str + v10), g5);
                v10++;
                while (v10 != (int64_t)v3) {
                    // 0x401900
                    putc((int32_t)*(char *)(*str + v10), g5);
                    v10++;
                }
                // 0x401937
                v9 = *v4;
            }
            int32_t v11 = v9; // 0x40199a
            if (v11 + v3 <= 29) {
                int32_t v12 = 30 - v3; // 0x4019a1
                struct _IO_FILE * stream3 = g5; // 0x4019ab
                if (v12 != v11) {
                    putc(32, g5);
                    int32_t v13 = 1; // 0x401981
                    struct _IO_FILE * stream2 = g5; // 0x4019ab
                    int32_t v14 = v13; // 0x4019ab
                    stream3 = g5;
                    while ((int64_t)v13 < (int64_t)(v12 - *v4)) {
                        // 0x40196d
                        putc(32, stream2);
                        v13 = v14 + 1;
                        stream2 = g5;
                        v14 = v13;
                        stream3 = g5;
                    }
                }
                // 0x4019ad
                putc(124, stream3);
            }
        }
        // 0x4019fe
        putc(10, g5);
    }
    // 0x401a20
    puts("\n");
    return sleep(1);
}

// Address range: 0x401a39 - 0x401b4d
int64_t function_401a39(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x401a49
    int32_t v2 = 0; // bp-24, 0x401a58
    int32_t v3 = 0; // bp-20, 0x401a5f
    puts("You may try to take a head start, if you get caught you will be banned from the races!");
    printf("Stable index # (0-%d)? ", 17);
    scanf("%d", &v2);
    if (v2 < 18) {
        // 0x401abd
        function_401226(*(int64_t *)(16 * (int64_t)v2 + a1), 16);
        printf("New spot? ");
        scanf("%d", &v3);
        *(int32_t *)(a1 + 8 + 16 * (int64_t)v2) = v3;
        printf("Modified horse in stable index %d\n", (int64_t)v2);
    } else {
        // 0x401aaf
        puts("Invalid stable index");
    }
    int64_t result = 0; // 0x401b44
    if (v1 != __readfsqword(40)) {
        // 0x401b46
        __stack_chk_fail();
        result = &g9;
    }
    // 0x401b4b
    return result;
}

// Address range: 0x401b4d - 0x401c0c
int64_t function_401b4d(void) {
    int64_t v1 = __readfsqword(40); // 0x401b59
    setbuf(g6, NULL);
    setbuf(g5, NULL);
    setbuf(g7, NULL);
    struct _IO_FILE * file = fopen("/dev/urandom", "r"); // 0x401bb2
    int32_t data = 0; // bp-28, 0x401bbb
    fread((int64_t *)&data, 4, 1, file);
    fclose(file);
    srand(data);
    int64_t result = 0; // 0x401c03
    if (v1 != __readfsqword(40)) {
        // 0x401c05
        __stack_chk_fail();
        result = &g9;
    }
    // 0x401c0a
    return result;
}

// Address range: 0x401c0c - 0x401e49
int64_t function_401c0c(int64_t a1, int64_t a2) {
    // 0x401c0c
    __readfsqword(40);
    int64_t * mem = malloc(288); // 0x401c33
    int32_t v1 = 0; // bp-36, 0x401c3c
    function_401b4d();
    function_40130f((int64_t)mem);
    puts("1. Add horse");
    puts("2. Remove horse");
    puts("3. Race");
    puts("4. Exit");
    printf("Choice: ");
    scanf("%d", &v1);
    uint32_t v2; // 0x401cdb
    if (v1 < 5) {
        // 0x401cca
        v2 = *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1);
        return (int64_t)v2 + (int64_t)&g1;
    }
    puts("Invalid choice");
    puts("1. Add horse");
    puts("2. Remove horse");
    puts("3. Race");
    puts("4. Exit");
    printf("Choice: ");
    scanf("%d", &v1);
    while (v1 >= 5) {
        // 0x401e0b
        puts("Invalid choice");
        puts("1. Add horse");
        puts("2. Remove horse");
        puts("3. Race");
        puts("4. Exit");
        printf("Choice: ");
        scanf("%d", &v1);
    }
    // 0x401cca
    v2 = *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1);
    return (int64_t)v2 + (int64_t)&g1;
}

// Address range: 0x401e50 - 0x401ead
int64_t function_401e50(int64_t a1, int64_t a2, int64_t a3) {
    int64_t result = function_401000(); // 0x401e78
    if ((int64_t)&g3 - (int64_t)&g2 >> 3 == 0) {
        // 0x401e9e
        return result;
    }
    int64_t v1 = 0; // 0x401e81
    while (v1 + 1 != (int64_t)&g3 - (int64_t)&g2 >> 3) {
        // 0x401e88
        v1++;
    }
    // 0x401e9e
    return result;
}

// Address range: 0x401eb0 - 0x401eb1
int64_t function_401eb0(void) {
    // 0x401eb0
    int64_t result; // 0x401eb0
    return result;
}

// Address range: 0x401eb4 - 0x401ebd
int64_t function_401eb4(void) {
    // 0x401eb4
    int64_t result; // 0x401eb4
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (9.4.0)
// Detected functions: 40

